// WebSocket Service\n// Real-time communication with â‰¤1s latency target\n\nimport type {\n  WebSocketEvent,\n  WebSocketEventType,\n  ChatMessage,\n  Conversation,\n  TypingIndicator\n} from '../types/chat';\n\nexport interface WebSocketConfig {\n  url: string;\n  reconnectInterval: number;\n  maxReconnectAttempts: number;\n  heartbeatInterval: number;\n  messageTimeout: number;\n  enableCompression: boolean;\n}\n\nexport interface ConnectionStatus {\n  connected: boolean;\n  connecting: boolean;\n  lastConnected?: Date;\n  reconnectAttempts: number;\n  latency?: number;\n  error?: string;\n}\n\nexport interface QueuedMessage {\n  id: string;\n  event: WebSocketEvent;\n  timestamp: Date;\n  attempts: number;\n  maxAttempts: number;\n}\n\nexport class WebSocketService {\n  private ws: WebSocket | null = null;\n  private config: WebSocketConfig;\n  private status: ConnectionStatus = {\n    connected: false,\n    connecting: false,\n    reconnectAttempts: 0\n  };\n  \n  private eventListeners: Map<WebSocketEventType, ((data: any) => void)[]> = new Map();\n  private messageQueue: QueuedMessage[] = [];\n  private heartbeatTimer: NodeJS.Timeout | null = null;\n  private reconnectTimer: NodeJS.Timeout | null = null;\n  private latencyTimer: NodeJS.Timeout | null = null;\n  \n  private lastHeartbeat: Date | null = null;\n  private messageTimeouts: Map<string, NodeJS.Timeout> = new Map();\n  \n  constructor(config: Partial<WebSocketConfig> = {}) {\n    this.config = {\n      url: config.url || 'ws://localhost:8080/ws',\n      reconnectInterval: config.reconnectInterval || 3000,\n      maxReconnectAttempts: config.maxReconnectAttempts || 10,\n      heartbeatInterval: config.heartbeatInterval || 30000,\n      messageTimeout: config.messageTimeout || 5000,\n      enableCompression: config.enableCompression ?? true\n    };\n  }\n\n  // Connection management\n  async connect(): Promise<void> {\n    if (this.status.connected || this.status.connecting) {\n      return;\n    }\n\n    this.status.connecting = true;\n    \n    try {\n      await this.createConnection();\n    } catch (error) {\n      this.status.connecting = false;\n      throw error;\n    }\n  }\n\n  private async createConnection(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        // Create WebSocket connection\n        this.ws = new WebSocket(this.config.url);\n        \n        // Set binary type for potential file transfers\n        this.ws.binaryType = 'arraybuffer';\n\n        // Connection opened\n        this.ws.onopen = () => {\n          console.log('[WebSocket] Connected to', this.config.url);\n          \n          this.status = {\n            connected: true,\n            connecting: false,\n            lastConnected: new Date(),\n            reconnectAttempts: 0\n          };\n          \n          this.startHeartbeat();\n          this.processMessageQueue();\n          this.emitStatusChange();\n          \n          resolve();\n        };\n\n        // Message received\n        this.ws.onmessage = (event) => {\n          this.handleMessage(event);\n        };\n\n        // Connection closed\n        this.ws.onclose = (event) => {\n          console.log('[WebSocket] Connection closed:', event.code, event.reason);\n          \n          this.status.connected = false;\n          this.status.connecting = false;\n          \n          this.stopHeartbeat();\n          this.emitStatusChange();\n          \n          // Attempt reconnection if not a clean close\n          if (event.code !== 1000 && this.status.reconnectAttempts < this.config.maxReconnectAttempts) {\n            this.scheduleReconnect();\n          }\n        };\n\n        // Connection error\n        this.ws.onerror = (error) => {\n          console.error('[WebSocket] Connection error:', error);\n          \n          this.status.error = 'Connection error';\n          this.status.connecting = false;\n          \n          this.emitStatusChange();\n          reject(new Error('WebSocket connection failed'));\n        };\n        \n      } catch (error) {\n        this.status.connecting = false;\n        reject(error);\n      }\n    });\n  }\n\n  disconnect(): void {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    \n    this.stopHeartbeat();\n    \n    if (this.ws) {\n      this.ws.close(1000, 'Client disconnect');\n      this.ws = null;\n    }\n    \n    this.status = {\n      connected: false,\n      connecting: false,\n      reconnectAttempts: 0\n    };\n    \n    this.emitStatusChange();\n  }\n\n  private scheduleReconnect(): void {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n    \n    this.status.reconnectAttempts++;\n    const delay = Math.min(\n      this.config.reconnectInterval * Math.pow(2, this.status.reconnectAttempts - 1),\n      30000 // Max 30 seconds\n    );\n    \n    console.log(`[WebSocket] Reconnecting in ${delay}ms (attempt ${this.status.reconnectAttempts})`);\n    \n    this.reconnectTimer = setTimeout(() => {\n      this.connect().catch(error => {\n        console.error('[WebSocket] Reconnection failed:', error);\n      });\n    }, delay);\n  }\n\n  // Message handling\n  private handleMessage(event: MessageEvent): void {\n    try {\n      const data = JSON.parse(event.data);\n      const wsEvent: WebSocketEvent = {\n        type: data.type,\n        data: data.data,\n        timestamp: data.timestamp || new Date().toISOString(),\n        conversationId: data.conversationId\n      };\n\n      // Handle heartbeat response\n      if (wsEvent.type === 'connection_status' && wsEvent.data?.type === 'pong') {\n        this.handleHeartbeatResponse(wsEvent);\n        return;\n      }\n\n      // Emit to listeners\n      this.emitEvent(wsEvent);\n      \n    } catch (error) {\n      console.error('[WebSocket] Failed to parse message:', error);\n    }\n  }\n\n  private handleHeartbeatResponse(event: WebSocketEvent): void {\n    if (this.lastHeartbeat) {\n      const latency = Date.now() - this.lastHeartbeat.getTime();\n      this.status.latency = latency;\n      \n      // Log high latency\n      if (latency > 1000) {\n        console.warn(`[WebSocket] High latency detected: ${latency}ms`);\n      }\n    }\n  }\n\n  // Event system\n  addEventListener(type: WebSocketEventType, listener: (data: any) => void): void {\n    if (!this.eventListeners.has(type)) {\n      this.eventListeners.set(type, []);\n    }\n    this.eventListeners.get(type)!.push(listener);\n  }\n\n  removeEventListener(type: WebSocketEventType, listener: (data: any) => void): void {\n    const listeners = this.eventListeners.get(type);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n\n  private emitEvent(event: WebSocketEvent): void {\n    const listeners = this.eventListeners.get(event.type);\n    if (listeners) {\n      listeners.forEach(listener => {\n        try {\n          listener(event.data);\n        } catch (error) {\n          console.error(`[WebSocket] Event listener error for ${event.type}:`, error);\n        }\n      });\n    }\n    \n    // Also emit to generic listeners\n    const genericListeners = this.eventListeners.get('connection_status');\n    if (genericListeners && event.type !== 'connection_status') {\n      genericListeners.forEach(listener => {\n        try {\n          listener({ type: 'event', event });\n        } catch (error) {\n          console.error('[WebSocket] Generic event listener error:', error);\n        }\n      });\n    }\n  }\n\n  private emitStatusChange(): void {\n    this.emitEvent({\n      type: 'connection_status',\n      data: { ...this.status },\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  // Message sending\n  sendEvent(event: WebSocketEvent): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!this.status.connected) {\n        // Queue message for later\n        this.queueMessage(event);\n        resolve();\n        return;\n      }\n\n      try {\n        const message = JSON.stringify(event);\n        this.ws!.send(message);\n        \n        // Set timeout for message acknowledgment\n        const timeoutId = setTimeout(() => {\n          console.warn('[WebSocket] Message timeout:', event.type);\n          this.messageTimeouts.delete(event.data?.id || 'unknown');\n        }, this.config.messageTimeout);\n        \n        if (event.data?.id) {\n          this.messageTimeouts.set(event.data.id, timeoutId);\n        }\n        \n        resolve();\n        \n      } catch (error) {\n        console.error('[WebSocket] Failed to send message:', error);\n        this.queueMessage(event);\n        reject(error);\n      }\n    });\n  }\n\n  // High-level message methods\n  async sendMessage(message: ChatMessage): Promise<void> {\n    await this.sendEvent({\n      type: 'message_sent',\n      data: message,\n      timestamp: new Date().toISOString(),\n      conversationId: message.conversationId\n    });\n  }\n\n  async sendTypingStart(conversationId: string, userId: string, userName: string): Promise<void> {\n    await this.sendEvent({\n      type: 'typing_start',\n      data: {\n        conversationId,\n        userId,\n        userName,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      conversationId\n    });\n  }\n\n  async sendTypingStop(conversationId: string, userId: string): Promise<void> {\n    await this.sendEvent({\n      type: 'typing_stop',\n      data: {\n        conversationId,\n        userId,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      conversationId\n    });\n  }\n\n  async joinConversation(conversationId: string, userId: string, userName: string): Promise<void> {\n    await this.sendEvent({\n      type: 'user_joined',\n      data: {\n        conversationId,\n        userId,\n        userName,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      conversationId\n    });\n  }\n\n  async leaveConversation(conversationId: string, userId: string): Promise<void> {\n    await this.sendEvent({\n      type: 'user_left',\n      data: {\n        conversationId,\n        userId,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      conversationId\n    });\n  }\n\n  // Message queue management\n  private queueMessage(event: WebSocketEvent): void {\n    const queuedMessage: QueuedMessage = {\n      id: event.data?.id || `queued_${Date.now()}`,\n      event,\n      timestamp: new Date(),\n      attempts: 0,\n      maxAttempts: 3\n    };\n    \n    this.messageQueue.push(queuedMessage);\n    \n    // Limit queue size\n    if (this.messageQueue.length > 100) {\n      this.messageQueue.shift(); // Remove oldest message\n    }\n  }\n\n  private async processMessageQueue(): Promise<void> {\n    if (!this.status.connected || this.messageQueue.length === 0) {\n      return;\n    }\n\n    const messagesToProcess = [...this.messageQueue];\n    this.messageQueue = [];\n    \n    for (const queuedMessage of messagesToProcess) {\n      try {\n        await this.sendEvent(queuedMessage.event);\n        console.log('[WebSocket] Queued message sent:', queuedMessage.id);\n      } catch (error) {\n        queuedMessage.attempts++;\n        \n        if (queuedMessage.attempts < queuedMessage.maxAttempts) {\n          this.messageQueue.push(queuedMessage);\n        } else {\n          console.error('[WebSocket] Failed to send queued message after max attempts:', queuedMessage.id);\n        }\n      }\n    }\n  }\n\n  // Heartbeat system\n  private startHeartbeat(): void {\n    this.stopHeartbeat();\n    \n    this.heartbeatTimer = setInterval(() => {\n      if (this.status.connected) {\n        this.sendHeartbeat();\n      }\n    }, this.config.heartbeatInterval);\n  }\n\n  private stopHeartbeat(): void {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = null;\n    }\n  }\n\n  private async sendHeartbeat(): Promise<void> {\n    this.lastHeartbeat = new Date();\n    \n    await this.sendEvent({\n      type: 'connection_status',\n      data: { type: 'ping', timestamp: this.lastHeartbeat.toISOString() },\n      timestamp: this.lastHeartbeat.toISOString()\n    });\n  }\n\n  // Status and metrics\n  getStatus(): ConnectionStatus {\n    return { ...this.status };\n  }\n\n  getMetrics(): {\n    connected: boolean;\n    latency?: number;\n    queuedMessages: number;\n    reconnectAttempts: number;\n    uptime?: number;\n  } {\n    const uptime = this.status.lastConnected \n      ? Date.now() - this.status.lastConnected.getTime()\n      : undefined;\n    \n    return {\n      connected: this.status.connected,\n      latency: this.status.latency,\n      queuedMessages: this.messageQueue.length,\n      reconnectAttempts: this.status.reconnectAttempts,\n      uptime\n    };\n  }\n\n  // Configuration\n  updateConfig(newConfig: Partial<WebSocketConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    \n    // Restart heartbeat if interval changed\n    if (newConfig.heartbeatInterval && this.status.connected) {\n      this.startHeartbeat();\n    }\n  }\n\n  // Cleanup\n  cleanup(): void {\n    this.disconnect();\n    \n    // Clear all timeouts\n    this.messageTimeouts.forEach(timeout => clearTimeout(timeout));\n    this.messageTimeouts.clear();\n    \n    // Clear event listeners\n    this.eventListeners.clear();\n    \n    // Clear message queue\n    this.messageQueue = [];\n    \n    console.log('[WebSocket] Cleanup completed');\n  }\n\n  // Health check\n  async healthCheck(): Promise<{\n    status: 'healthy' | 'degraded' | 'unhealthy';\n    details: Record<string, any>;\n  }> {\n    const metrics = this.getMetrics();\n    \n    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n    \n    if (!metrics.connected) {\n      status = 'unhealthy';\n    } else if (metrics.latency && metrics.latency > 1000) {\n      status = 'degraded';\n    } else if (metrics.queuedMessages > 10) {\n      status = 'degraded';\n    }\n\n    return {\n      status,\n      details: {\n        ...metrics,\n        config: {\n          url: this.config.url,\n          heartbeatInterval: this.config.heartbeatInterval,\n          maxReconnectAttempts: this.config.maxReconnectAttempts\n        },\n        timestamp: new Date().toISOString()\n      }\n    };\n  }\n}\n\n// Export singleton instance\nexport const websocketService = new WebSocketService();\n