// Privacy & Consent Management Service\n// GDPR/PDPA compliant privacy and consent handling\n\nexport type ConsentType = \n  | 'essential' \n  | 'analytics' \n  | 'marketing' \n  | 'personalization' \n  | 'chat_data_collection'\n  | 'contact_information'\n  | 'usage_analytics'\n  | 'error_reporting';\n\nexport type ConsentStatus = 'granted' | 'denied' | 'pending' | 'withdrawn';\n\nexport interface ConsentRecord {\n  id: string;\n  userId?: string;\n  sessionId: string;\n  type: ConsentType;\n  status: ConsentStatus;\n  version: string; // Privacy policy version\n  grantedAt?: string;\n  withdrawnAt?: string;\n  expiresAt?: string;\n  ipAddress?: string;\n  userAgent?: string;\n  source: 'explicit' | 'implicit' | 'legitimate_interest';\n  metadata?: Record<string, any>;\n}\n\nexport interface PrivacySettings {\n  dataRetentionDays: number;\n  anonymizeAfterDays: number;\n  allowDataExport: boolean;\n  allowDataDeletion: boolean;\n  requireExplicitConsent: boolean;\n  cookieConsentRequired: boolean;\n  trackingOptOut: boolean;\n  contactDataMinimization: boolean;\n}\n\nexport interface DataProcessingPurpose {\n  id: string;\n  name: string;\n  description: string;\n  legalBasis: 'consent' | 'contract' | 'legal_obligation' | 'vital_interests' | 'public_task' | 'legitimate_interests';\n  dataTypes: string[];\n  retentionPeriod: number; // days\n  required: boolean;\n  consentType: ConsentType;\n}\n\nexport interface PrivacyNotice {\n  version: string;\n  effectiveDate: string;\n  language: string;\n  title: string;\n  summary: string;\n  fullText: string;\n  purposes: DataProcessingPurpose[];\n  thirdParties: {\n    name: string;\n    purpose: string;\n    dataTypes: string[];\n    privacyPolicy: string;\n  }[];\n  userRights: string[];\n  contactInfo: {\n    dpo?: string; // Data Protection Officer\n    email: string;\n    address?: string;\n  };\n}\n\nexport interface DataSubjectRequest {\n  id: string;\n  userId?: string;\n  email: string;\n  type: 'access' | 'rectification' | 'erasure' | 'portability' | 'restriction' | 'objection';\n  status: 'pending' | 'in_progress' | 'completed' | 'rejected';\n  description: string;\n  requestedAt: string;\n  completedAt?: string;\n  response?: string;\n  attachments?: string[];\n  verificationMethod: 'email' | 'phone' | 'identity_document';\n  verifiedAt?: string;\n}\n\nexport class PrivacyService {\n  private consents: Map<string, ConsentRecord[]> = new Map();\n  private settings: PrivacySettings;\n  private currentNotice: PrivacyNotice;\n  private dataRequests: Map<string, DataSubjectRequest> = new Map();\n\n  constructor() {\n    this.settings = this.getDefaultSettings();\n    this.currentNotice = this.getDefaultNotice();\n    this.loadStoredConsents();\n  }\n\n  private getDefaultSettings(): PrivacySettings {\n    return {\n      dataRetentionDays: 365 * 2, // 2 years\n      anonymizeAfterDays: 365 * 7, // 7 years\n      allowDataExport: true,\n      allowDataDeletion: true,\n      requireExplicitConsent: true,\n      cookieConsentRequired: true,\n      trackingOptOut: true,\n      contactDataMinimization: true\n    };\n  }\n\n  private getDefaultNotice(): PrivacyNotice {\n    return {\n      version: '1.0.0',\n      effectiveDate: '2024-08-15T00:00:00Z',\n      language: 'th',\n      title: 'นโยบายความเป็นส่วนตัว - Saku Dojo',\n      summary: 'เราเก็บรวบรวมข้อมูลเพื่อปรับปรุงประสบการณ์การเรียนรู้ของคุณ โดยเคารพสิทธิความเป็นส่วนตัวของคุณ',\n      fullText: `# นโยบายความเป็นส่วนตัว\n\n## การเก็บรวบรวมข้อมูล\nเราเก็บรวบรวมข้อมูลที่จำเป็นเพื่อให้บริการการเรียนรู้ภาษาที่ดีที่สุดแก่คุณ\n\n## การใช้ข้อมูล\nข้อมูลของคุณจะถูกใช้เพื่อ:\n- ปรับปรุงประสบการณ์การเรียนรู้\n- ให้การสนับสนุนทางเทคนิค\n- วิเคราะห์การใช้งานเพื่อพัฒนาแอป\n\n## สิทธิของคุณ\nคุณมีสิทธิในการ:\n- เข้าถึงข้อมูลส่วนบุคคล\n- แก้ไขข้อมูลที่ไม่ถูกต้อง\n- ลบข้อมูลส่วนบุคคล\n- ส่งออกข้อมูลของคุณ\n- คัดค้านการประมวลผลข้อมูล`,\n      purposes: [\n        {\n          id: 'essential_service',\n          name: 'การให้บริการหลัก',\n          description: 'ข้อมูลที่จำเป็นสำหรับการใช้งานแอป',\n          legalBasis: 'contract',\n          dataTypes: ['user_id', 'session_data', 'progress_data'],\n          retentionPeriod: 365 * 2,\n          required: true,\n          consentType: 'essential'\n        },\n        {\n          id: 'chat_support',\n          name: 'การสนับสนุนผ่านแชท',\n          description: 'ข้อมูลการสนทนาเพื่อให้การช่วยเหลือ',\n          legalBasis: 'consent',\n          dataTypes: ['chat_messages', 'contact_info', 'device_info'],\n          retentionPeriod: 365,\n          required: false,\n          consentType: 'chat_data_collection'\n        },\n        {\n          id: 'analytics',\n          name: 'การวิเคราะห์การใช้งาน',\n          description: 'ข้อมูลการใช้งานเพื่อปรับปรุงแอป',\n          legalBasis: 'consent',\n          dataTypes: ['usage_patterns', 'performance_metrics', 'error_logs'],\n          retentionPeriod: 365,\n          required: false,\n          consentType: 'usage_analytics'\n        }\n      ],\n      thirdParties: [\n        {\n          name: 'Telegram',\n          purpose: 'การส่งการแจ้งเตือนผ่าน Telegram',\n          dataTypes: ['telegram_user_id', 'messages'],\n          privacyPolicy: 'https://telegram.org/privacy'\n        },\n        {\n          name: 'Facebook Messenger',\n          purpose: 'การส่งการแจ้งเตือนผ่าน Messenger',\n          dataTypes: ['messenger_user_id', 'messages'],\n          privacyPolicy: 'https://www.facebook.com/privacy/policy'\n        }\n      ],\n      userRights: [\n        'สิทธิในการเข้าถึงข้อมูล',\n        'สิทธิในการแก้ไขข้อมูล',\n        'สิทธิในการลบข้อมูล',\n        'สิทธิในการส่งออกข้อมูล',\n        'สิทธิในการคัดค้านการประมวลผล',\n        'สิทธิในการจำกัดการประมวลผล'\n      ],\n      contactInfo: {\n        email: 'privacy@sakudojo.com',\n        address: 'Bangkok, Thailand'\n      }\n    };\n  }\n\n  // Consent Management\n  async grantConsent(\n    sessionId: string,\n    type: ConsentType,\n    userId?: string,\n    metadata?: Record<string, any>\n  ): Promise<ConsentRecord> {\n    const consent: ConsentRecord = {\n      id: `consent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      userId,\n      sessionId,\n      type,\n      status: 'granted',\n      version: this.currentNotice.version,\n      grantedAt: new Date().toISOString(),\n      source: 'explicit',\n      metadata\n    };\n\n    // Store consent\n    const userConsents = this.consents.get(sessionId) || [];\n    \n    // Remove any existing consent for this type\n    const filteredConsents = userConsents.filter(c => c.type !== type);\n    filteredConsents.push(consent);\n    \n    this.consents.set(sessionId, filteredConsents);\n    this.saveConsents();\n\n    console.log(`[Privacy] Consent granted: ${type} for session ${sessionId}`);\n    return consent;\n  }\n\n  async withdrawConsent(\n    sessionId: string,\n    type: ConsentType,\n    userId?: string\n  ): Promise<ConsentRecord | null> {\n    const userConsents = this.consents.get(sessionId) || [];\n    const existingConsent = userConsents.find(c => c.type === type && c.status === 'granted');\n    \n    if (!existingConsent) {\n      return null;\n    }\n\n    // Update existing consent\n    existingConsent.status = 'withdrawn';\n    existingConsent.withdrawnAt = new Date().toISOString();\n\n    this.consents.set(sessionId, userConsents);\n    this.saveConsents();\n\n    console.log(`[Privacy] Consent withdrawn: ${type} for session ${sessionId}`);\n    return existingConsent;\n  }\n\n  hasConsent(sessionId: string, type: ConsentType): boolean {\n    const userConsents = this.consents.get(sessionId) || [];\n    const consent = userConsents.find(c => c.type === type);\n    \n    if (!consent) {\n      // Check if this is essential consent (always granted)\n      return type === 'essential';\n    }\n\n    // Check if consent is still valid\n    if (consent.status !== 'granted') {\n      return false;\n    }\n\n    // Check expiration\n    if (consent.expiresAt && new Date(consent.expiresAt) < new Date()) {\n      return false;\n    }\n\n    return true;\n  }\n\n  getConsents(sessionId: string): ConsentRecord[] {\n    return this.consents.get(sessionId) || [];\n  }\n\n  getAllConsents(): ConsentRecord[] {\n    const allConsents: ConsentRecord[] = [];\n    for (const consents of this.consents.values()) {\n      allConsents.push(...consents);\n    }\n    return allConsents;\n  }\n\n  // Privacy Notice Management\n  getPrivacyNotice(language: string = 'th'): PrivacyNotice {\n    // In a real implementation, you'd fetch the notice for the specific language\n    return this.currentNotice;\n  }\n\n  updatePrivacyNotice(notice: PrivacyNotice): void {\n    this.currentNotice = notice;\n    // In a real implementation, you'd save this to a database\n    console.log(`[Privacy] Privacy notice updated to version ${notice.version}`);\n  }\n\n  // Data Subject Rights\n  async submitDataRequest(\n    email: string,\n    type: DataSubjectRequest['type'],\n    description: string,\n    userId?: string\n  ): Promise<DataSubjectRequest> {\n    const request: DataSubjectRequest = {\n      id: `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      userId,\n      email,\n      type,\n      status: 'pending',\n      description,\n      requestedAt: new Date().toISOString(),\n      verificationMethod: 'email'\n    };\n\n    this.dataRequests.set(request.id, request);\n    \n    // In a real implementation, you'd:\n    // 1. Send verification email\n    // 2. Store in database\n    // 3. Notify data protection team\n    \n    console.log(`[Privacy] Data subject request submitted: ${type} for ${email}`);\n    return request;\n  }\n\n  async getDataRequest(requestId: string): Promise<DataSubjectRequest | null> {\n    return this.dataRequests.get(requestId) || null;\n  }\n\n  async updateDataRequest(\n    requestId: string,\n    updates: Partial<DataSubjectRequest>\n  ): Promise<DataSubjectRequest | null> {\n    const request = this.dataRequests.get(requestId);\n    if (!request) return null;\n\n    Object.assign(request, updates);\n    this.dataRequests.set(requestId, request);\n    \n    console.log(`[Privacy] Data request updated: ${requestId}`);\n    return request;\n  }\n\n  // Data Export\n  async exportUserData(userId: string): Promise<{\n    success: boolean;\n    data?: any;\n    error?: string;\n  }> {\n    try {\n      // In a real implementation, you'd collect all user data from various sources\n      const userData = {\n        profile: {\n          userId,\n          exportedAt: new Date().toISOString(),\n          version: '1.0'\n        },\n        consents: this.getAllConsents().filter(c => c.userId === userId),\n        chatData: {\n          conversations: [], // Would fetch from database\n          messages: [] // Would fetch from database\n        },\n        learningData: {\n          progress: {}, // Would fetch from learning system\n          preferences: {} // Would fetch from settings\n        },\n        metadata: {\n          dataRetentionPolicy: this.settings.dataRetentionDays,\n          privacyNoticeVersion: this.currentNotice.version\n        }\n      };\n\n      return { success: true, data: userData };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Export failed'\n      };\n    }\n  }\n\n  // Data Deletion\n  async deleteUserData(userId: string, type: 'soft' | 'hard' = 'soft'): Promise<{\n    success: boolean;\n    deletedItems: number;\n    error?: string;\n  }> {\n    try {\n      let deletedItems = 0;\n\n      if (type === 'hard') {\n        // Hard delete - completely remove data\n        // Remove consents\n        for (const [sessionId, consents] of this.consents.entries()) {\n          const filteredConsents = consents.filter(c => c.userId !== userId);\n          if (filteredConsents.length !== consents.length) {\n            this.consents.set(sessionId, filteredConsents);\n            deletedItems += consents.length - filteredConsents.length;\n          }\n        }\n        \n        // In a real implementation, you'd also delete:\n        // - Chat messages and conversations\n        // - Learning progress and preferences\n        // - Analytics data\n        // - File attachments\n        \n      } else {\n        // Soft delete - anonymize data\n        for (const consents of this.consents.values()) {\n          consents.forEach(consent => {\n            if (consent.userId === userId) {\n              consent.userId = `anonymized_${Date.now()}`;\n              deletedItems++;\n            }\n          });\n        }\n      }\n\n      this.saveConsents();\n      \n      console.log(`[Privacy] User data ${type} deleted: ${userId}, ${deletedItems} items`);\n      return { success: true, deletedItems };\n      \n    } catch (error) {\n      return {\n        success: false,\n        deletedItems: 0,\n        error: error instanceof Error ? error.message : 'Deletion failed'\n      };\n    }\n  }\n\n  // Data Retention\n  async cleanupExpiredData(): Promise<{\n    deletedConsents: number;\n    anonymizedRecords: number;\n  }> {\n    const now = new Date();\n    const retentionDate = new Date(now.getTime() - this.settings.dataRetentionDays * 24 * 60 * 60 * 1000);\n    const anonymizeDate = new Date(now.getTime() - this.settings.anonymizeAfterDays * 24 * 60 * 60 * 1000);\n    \n    let deletedConsents = 0;\n    let anonymizedRecords = 0;\n\n    // Clean up expired consents\n    for (const [sessionId, consents] of this.consents.entries()) {\n      const validConsents = consents.filter(consent => {\n        const consentDate = new Date(consent.grantedAt || consent.withdrawnAt || '1970-01-01');\n        \n        if (consentDate < retentionDate) {\n          deletedConsents++;\n          return false;\n        }\n        \n        if (consentDate < anonymizeDate && consent.userId) {\n          consent.userId = `anonymized_${Date.now()}`;\n          consent.ipAddress = undefined;\n          consent.userAgent = undefined;\n          anonymizedRecords++;\n        }\n        \n        return true;\n      });\n      \n      this.consents.set(sessionId, validConsents);\n    }\n\n    this.saveConsents();\n    \n    console.log(`[Privacy] Cleanup completed: ${deletedConsents} deleted, ${anonymizedRecords} anonymized`);\n    return { deletedConsents, anonymizedRecords };\n  }\n\n  // Storage Management\n  private loadStoredConsents(): void {\n    try {\n      const stored = localStorage.getItem('saku_dojo_consents');\n      if (stored) {\n        const data = JSON.parse(stored);\n        this.consents = new Map(Object.entries(data));\n      }\n    } catch (error) {\n      console.warn('[Privacy] Failed to load stored consents:', error);\n    }\n  }\n\n  private saveConsents(): void {\n    try {\n      const data = Object.fromEntries(this.consents.entries());\n      localStorage.setItem('saku_dojo_consents', JSON.stringify(data));\n    } catch (error) {\n      console.warn('[Privacy] Failed to save consents:', error);\n    }\n  }\n\n  // Settings Management\n  updateSettings(newSettings: Partial<PrivacySettings>): void {\n    this.settings = { ...this.settings, ...newSettings };\n    console.log('[Privacy] Settings updated');\n  }\n\n  getSettings(): PrivacySettings {\n    return { ...this.settings };\n  }\n\n  // Compliance Reporting\n  async generateComplianceReport(): Promise<{\n    totalConsents: number;\n    consentsByType: Record<ConsentType, number>;\n    consentsByStatus: Record<ConsentStatus, number>;\n    dataRequests: {\n      total: number;\n      byType: Record<string, number>;\n      byStatus: Record<string, number>;\n    };\n    retentionCompliance: {\n      itemsToDelete: number;\n      itemsToAnonymize: number;\n    };\n    generatedAt: string;\n  }> {\n    const allConsents = this.getAllConsents();\n    const allRequests = Array.from(this.dataRequests.values());\n    \n    const consentsByType = allConsents.reduce((acc, consent) => {\n      acc[consent.type] = (acc[consent.type] || 0) + 1;\n      return acc;\n    }, {} as Record<ConsentType, number>);\n    \n    const consentsByStatus = allConsents.reduce((acc, consent) => {\n      acc[consent.status] = (acc[consent.status] || 0) + 1;\n      return acc;\n    }, {} as Record<ConsentStatus, number>);\n    \n    const requestsByType = allRequests.reduce((acc, req) => {\n      acc[req.type] = (acc[req.type] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n    \n    const requestsByStatus = allRequests.reduce((acc, req) => {\n      acc[req.status] = (acc[req.status] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n    \n    // Calculate retention compliance\n    const now = new Date();\n    const retentionDate = new Date(now.getTime() - this.settings.dataRetentionDays * 24 * 60 * 60 * 1000);\n    const anonymizeDate = new Date(now.getTime() - this.settings.anonymizeAfterDays * 24 * 60 * 60 * 1000);\n    \n    const itemsToDelete = allConsents.filter(c => {\n      const date = new Date(c.grantedAt || c.withdrawnAt || '1970-01-01');\n      return date < retentionDate;\n    }).length;\n    \n    const itemsToAnonymize = allConsents.filter(c => {\n      const date = new Date(c.grantedAt || c.withdrawnAt || '1970-01-01');\n      return date < anonymizeDate && c.userId && !c.userId.startsWith('anonymized_');\n    }).length;\n\n    return {\n      totalConsents: allConsents.length,\n      consentsByType,\n      consentsByStatus,\n      dataRequests: {\n        total: allRequests.length,\n        byType: requestsByType,\n        byStatus: requestsByStatus\n      },\n      retentionCompliance: {\n        itemsToDelete,\n        itemsToAnonymize\n      },\n      generatedAt: new Date().toISOString()\n    };\n  }\n\n  // Health Check\n  async healthCheck(): Promise<{\n    status: 'healthy' | 'degraded' | 'unhealthy';\n    details: Record<string, any>;\n  }> {\n    const report = await this.generateComplianceReport();\n    \n    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n    \n    // Check for compliance issues\n    if (report.retentionCompliance.itemsToDelete > 100) {\n      status = 'degraded';\n    }\n    \n    if (report.retentionCompliance.itemsToDelete > 1000) {\n      status = 'unhealthy';\n    }\n    \n    return {\n      status,\n      details: {\n        ...report,\n        settings: this.settings,\n        privacyNoticeVersion: this.currentNotice.version\n      }\n    };\n  }\n}\n\n// Export singleton instance\nexport const privacyService = new PrivacyService();\n