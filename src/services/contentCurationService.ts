// Content Curation Service\n// Automated and manual content curation with quality assurance\n\nimport type { \n  QuestionItem, \n  QuestionCollection, \n  ValidationResult,\n  Source \n} from '../types/questionBank';\nimport type { StarterDeckMeta } from '../data/starterDecks';\nimport { QualityValidator } from '../etl/validators';\nimport { QUALITY_RULES } from '../etl/config';\n\nexport interface CurationRule {\n  id: string;\n  name: string;\n  description: string;\n  category: 'content' | 'difficulty' | 'licensing' | 'cultural' | 'educational';\n  severity: 'error' | 'warning' | 'info';\n  check: (item: QuestionItem) => boolean;\n  autoFix?: (item: QuestionItem) => QuestionItem;\n  message: (item: QuestionItem) => string;\n}\n\nexport interface CurationBatch {\n  id: string;\n  name: string;\n  description: string;\n  items: QuestionItem[];\n  rules: string[]; // Rule IDs to apply\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n  progress: number;\n  results?: CurationResult;\n  createdAt: string;\n  completedAt?: string;\n}\n\nexport interface CurationResult {\n  totalItems: number;\n  approvedItems: number;\n  rejectedItems: number;\n  flaggedItems: number;\n  autoFixedItems: number;\n  issues: CurationIssue[];\n  qualityScore: number;\n  recommendations: string[];\n}\n\nexport interface CurationIssue {\n  itemId: string;\n  ruleId: string;\n  severity: 'error' | 'warning' | 'info';\n  message: string;\n  suggestion?: string;\n  autoFixed: boolean;\n}\n\nexport class ContentCurationService {\n  private validator: QualityValidator;\n  private rules: Map<string, CurationRule> = new Map();\n  private batches: Map<string, CurationBatch> = new Map();\n\n  constructor() {\n    this.validator = new QualityValidator(QUALITY_RULES);\n    this.initializeCurationRules();\n  }\n\n  // Initialize curation rules\n  private initializeCurationRules(): void {\n    const rules: CurationRule[] = [\n      // Content Quality Rules\n      {\n        id: 'appropriate-content',\n        name: 'Appropriate Content',\n        description: 'Content should be appropriate for educational use',\n        category: 'content',\n        severity: 'error',\n        check: (item) => {\n          const content = `${item.prompt} ${item.explanation || ''}`;\n          return !this.containsInappropriateContent(content);\n        },\n        message: () => 'Content contains inappropriate material',\n      },\n      \n      {\n        id: 'cultural-sensitivity',\n        name: 'Cultural Sensitivity',\n        description: 'Content should be culturally sensitive and inclusive',\n        category: 'cultural',\n        severity: 'warning',\n        check: (item) => {\n          const content = `${item.prompt} ${item.explanation || ''}`;\n          return !this.containsCulturallyInsensitiveContent(content);\n        },\n        message: () => 'Content may contain culturally insensitive material',\n      },\n      \n      {\n        id: 'educational-value',\n        name: 'Educational Value',\n        description: 'Content should have clear educational value',\n        category: 'educational',\n        severity: 'warning',\n        check: (item) => {\n          // Check if question has educational merit\n          return item.explanation && item.explanation.length > 10;\n        },\n        autoFix: (item) => {\n          if (!item.explanation) {\n            return {\n              ...item,\n              explanation: this.generateBasicExplanation(item)\n            };\n          }\n          return item;\n        },\n        message: () => 'Item lacks sufficient educational explanation',\n      },\n      \n      {\n        id: 'difficulty-consistency',\n        name: 'Difficulty Consistency',\n        description: 'Difficulty should match the assigned level',\n        category: 'difficulty',\n        severity: 'warning',\n        check: (item) => {\n          if (!item.difficulty || !item.level) return true;\n          \n          const expectedDifficulty = this.getExpectedDifficulty(item.level);\n          const actualDifficulty = item.difficulty.overallDifficulty || 5;\n          \n          return Math.abs(actualDifficulty - expectedDifficulty) <= 2;\n        },\n        message: (item) => {\n          const expected = this.getExpectedDifficulty(item.level);\n          const actual = item.difficulty?.overallDifficulty || 5;\n          return `Difficulty mismatch: expected ~${expected}, got ${actual}`;\n        },\n      },\n      \n      {\n        id: 'source-attribution',\n        name: 'Source Attribution',\n        description: 'All content must have proper source attribution',\n        category: 'licensing',\n        severity: 'error',\n        check: (item) => {\n          return !!(item.source && item.source.name && item.source.license && item.source.attribution);\n        },\n        message: () => 'Missing or incomplete source attribution',\n      },\n      \n      {\n        id: 'license-compliance',\n        name: 'License Compliance',\n        description: 'Content must comply with source license requirements',\n        category: 'licensing',\n        severity: 'error',\n        check: (item) => {\n          if (!item.source) return false;\n          return this.checkLicenseCompliance(item.source);\n        },\n        message: (item) => `License compliance issue: ${item.source?.license}`,\n      },\n      \n      {\n        id: 'duplicate-detection',\n        name: 'Duplicate Detection',\n        description: 'Detect and flag potential duplicate content',\n        category: 'content',\n        severity: 'warning',\n        check: (item) => {\n          // Simplified duplicate check - in reality would use more sophisticated matching\n          return true; // Placeholder\n        },\n        message: () => 'Potential duplicate content detected',\n      },\n      \n      {\n        id: 'language-accuracy',\n        name: 'Language Accuracy',\n        description: 'Content should be linguistically accurate',\n        category: 'educational',\n        severity: 'warning',\n        check: (item) => {\n          // Basic language accuracy checks\n          if (item.language === 'EN') {\n            return this.checkEnglishAccuracy(item);\n          } else if (item.language === 'JP') {\n            return this.checkJapaneseAccuracy(item);\n          }\n          return true;\n        },\n        message: () => 'Potential language accuracy issue detected',\n      },\n      \n      {\n        id: 'answer-correctness',\n        name: 'Answer Correctness',\n        description: 'Answers should be correct and unambiguous',\n        category: 'educational',\n        severity: 'error',\n        check: (item) => {\n          // Check answer validity\n          if (item.choices && typeof item.answer === 'number') {\n            return item.answer >= 0 && item.answer < item.choices.length;\n          }\n          return item.answer !== undefined && item.answer !== null;\n        },\n        message: () => 'Answer is incorrect or invalid',\n      },\n      \n      {\n        id: 'tag-relevance',\n        name: 'Tag Relevance',\n        description: 'Tags should be relevant and helpful for discovery',\n        category: 'content',\n        severity: 'info',\n        check: (item) => {\n          return item.tags && item.tags.length >= 2 && item.tags.length <= 8;\n        },\n        autoFix: (item) => {\n          if (!item.tags || item.tags.length === 0) {\n            return {\n              ...item,\n              tags: this.generateRelevantTags(item)\n            };\n          }\n          return item;\n        },\n        message: () => 'Tags need improvement for better discoverability',\n      }\n    ];\n\n    rules.forEach(rule => {\n      this.rules.set(rule.id, rule);\n    });\n  }\n\n  // Create a new curation batch\n  async createCurationBatch(\n    name: string,\n    description: string,\n    items: QuestionItem[],\n    ruleIds?: string[]\n  ): Promise<string> {\n    const batchId = `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const batch: CurationBatch = {\n      id: batchId,\n      name,\n      description,\n      items,\n      rules: ruleIds || Array.from(this.rules.keys()),\n      status: 'pending',\n      progress: 0,\n      createdAt: new Date().toISOString()\n    };\n\n    this.batches.set(batchId, batch);\n    return batchId;\n  }\n\n  // Process a curation batch\n  async processBatch(batchId: string): Promise<CurationResult> {\n    const batch = this.batches.get(batchId);\n    if (!batch) {\n      throw new Error(`Batch ${batchId} not found`);\n    }\n\n    batch.status = 'in_progress';\n    batch.progress = 0;\n\n    const issues: CurationIssue[] = [];\n    const processedItems: QuestionItem[] = [];\n    let approvedCount = 0;\n    let rejectedCount = 0;\n    let flaggedCount = 0;\n    let autoFixedCount = 0;\n\n    for (let i = 0; i < batch.items.length; i++) {\n      let item = batch.items[i];\n      let itemApproved = true;\n      let itemAutoFixed = false;\n\n      // Apply each rule\n      for (const ruleId of batch.rules) {\n        const rule = this.rules.get(ruleId);\n        if (!rule) continue;\n\n        const passed = rule.check(item);\n        \n        if (!passed) {\n          const issue: CurationIssue = {\n            itemId: item.id,\n            ruleId: rule.id,\n            severity: rule.severity,\n            message: rule.message(item),\n            autoFixed: false\n          };\n\n          // Try auto-fix if available\n          if (rule.autoFix) {\n            const fixedItem = rule.autoFix(item);\n            if (fixedItem !== item) {\n              item = fixedItem;\n              issue.autoFixed = true;\n              itemAutoFixed = true;\n              issue.suggestion = 'Item was automatically fixed';\n            }\n          }\n\n          issues.push(issue);\n\n          // Determine item status based on severity\n          if (rule.severity === 'error' && !issue.autoFixed) {\n            itemApproved = false;\n          } else if (rule.severity === 'warning') {\n            // Item is flagged but not rejected\n          }\n        }\n      }\n\n      // Update counters\n      if (itemApproved) {\n        approvedCount++;\n        if (issues.some(issue => issue.itemId === item.id && issue.severity === 'warning')) {\n          flaggedCount++;\n        }\n      } else {\n        rejectedCount++;\n      }\n\n      if (itemAutoFixed) {\n        autoFixedCount++;\n      }\n\n      processedItems.push(item);\n      \n      // Update progress\n      batch.progress = Math.round(((i + 1) / batch.items.length) * 100);\n    }\n\n    // Calculate quality score\n    const qualityScore = this.calculateBatchQualityScore(issues, batch.items.length);\n\n    // Generate recommendations\n    const recommendations = this.generateRecommendations(issues, batch.items.length);\n\n    const result: CurationResult = {\n      totalItems: batch.items.length,\n      approvedItems: approvedCount,\n      rejectedItems: rejectedCount,\n      flaggedItems: flaggedCount,\n      autoFixedItems: autoFixedCount,\n      issues,\n      qualityScore,\n      recommendations\n    };\n\n    batch.status = 'completed';\n    batch.results = result;\n    batch.completedAt = new Date().toISOString();\n    batch.items = processedItems; // Update with fixed items\n\n    return result;\n  }\n\n  // Get batch status\n  async getBatchStatus(batchId: string): Promise<CurationBatch | null> {\n    return this.batches.get(batchId) || null;\n  }\n\n  // Get all batches\n  async getAllBatches(): Promise<CurationBatch[]> {\n    return Array.from(this.batches.values())\n      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n  }\n\n  // Random sampling for quality checks\n  async performRandomQualityCheck(\n    items: QuestionItem[],\n    samplePercentage: number = 10\n  ): Promise<CurationResult> {\n    const sampleSize = Math.max(1, Math.floor(items.length * (samplePercentage / 100)));\n    const sampledItems = this.randomSample(items, sampleSize);\n    \n    const batchId = await this.createCurationBatch(\n      `Random Quality Check ${new Date().toISOString()}`,\n      `Random sample of ${sampleSize} items (${samplePercentage}% of ${items.length} total)`,\n      sampledItems\n    );\n\n    return this.processBatch(batchId);\n  }\n\n  // Helper methods\n  private containsInappropriateContent(content: string): boolean {\n    // Simplified inappropriate content detection\n    const inappropriateWords = ['hate', 'violence', 'discrimination'];\n    const lowerContent = content.toLowerCase();\n    return inappropriateWords.some(word => lowerContent.includes(word));\n  }\n\n  private containsCulturallyInsensitiveContent(content: string): boolean {\n    // Simplified cultural sensitivity check\n    const sensitiveTerms = ['stereotype', 'prejudice', 'bias'];\n    const lowerContent = content.toLowerCase();\n    return sensitiveTerms.some(term => lowerContent.includes(term));\n  }\n\n  private generateBasicExplanation(item: QuestionItem): string {\n    if (item.type === 'vocab') {\n      return `This ${item.type} question helps you learn important vocabulary.`;\n    }\n    return `This ${item.type} question helps you practice ${item.type} skills.`;\n  }\n\n  private getExpectedDifficulty(level: any): number {\n    if (level.system === 'CEFR') {\n      const levelMap: Record<string, number> = {\n        'A1': 2, 'A2': 3, 'B1': 5, 'B2': 6, 'C1': 8, 'C2': 9\n      };\n      return levelMap[level.level] || 5;\n    } else if (level.system === 'JLPT') {\n      const levelMap: Record<string, number> = {\n        'N5': 2, 'N4': 4, 'N3': 5, 'N2': 7, 'N1': 9\n      };\n      return levelMap[level.level] || 5;\n    }\n    return parseInt(level.level) || 5;\n  }\n\n  private checkLicenseCompliance(source: Source): boolean {\n    const validLicenses = ['CC-BY', 'CC-BY-SA', 'CC-BY-NC', 'CC-BY-NC-SA', 'EDRDG', 'Public-Domain', 'Other'];\n    return validLicenses.includes(source.license);\n  }\n\n  private checkEnglishAccuracy(item: QuestionItem): boolean {\n    // Basic English accuracy checks\n    const text = item.prompt + ' ' + (item.explanation || '');\n    \n    // Check for common issues\n    if (text.includes('  ')) return false; // Double spaces\n    if (!/^[A-Z]/.test(item.prompt)) return false; // Should start with capital\n    if (!/[.!?]$/.test(item.prompt)) return false; // Should end with punctuation\n    \n    return true;\n  }\n\n  private checkJapaneseAccuracy(item: QuestionItem): boolean {\n    // Basic Japanese accuracy checks\n    const text = item.prompt + ' ' + (item.explanation || '');\n    \n    // Check for mixed scripts appropriateness\n    const hasHiragana = /[\\u3040-\\u309F]/.test(text);\n    const hasKatakana = /[\\u30A0-\\u30FF]/.test(text);\n    const hasKanji = /[\\u4E00-\\u9FAF]/.test(text);\n    \n    // Should have at least one Japanese script\n    return hasHiragana || hasKatakana || hasKanji;\n  }\n\n  private generateRelevantTags(item: QuestionItem): string[] {\n    const tags = [item.type, item.language.toLowerCase()];\n    \n    if (item.level) {\n      tags.push(item.level.system.toLowerCase());\n      tags.push(item.level.level.toLowerCase());\n    }\n    \n    // Add difficulty-based tags\n    if (item.difficulty) {\n      const difficulty = item.difficulty.overallDifficulty || 5;\n      if (difficulty <= 3) tags.push('easy');\n      else if (difficulty <= 6) tags.push('medium');\n      else tags.push('hard');\n    }\n    \n    return tags;\n  }\n\n  private calculateBatchQualityScore(issues: CurationIssue[], totalItems: number): number {\n    let score = 1.0;\n    \n    const errorCount = issues.filter(i => i.severity === 'error' && !i.autoFixed).length;\n    const warningCount = issues.filter(i => i.severity === 'warning').length;\n    \n    score -= (errorCount / totalItems) * 0.5;\n    score -= (warningCount / totalItems) * 0.2;\n    \n    return Math.max(0, Math.min(1, score));\n  }\n\n  private generateRecommendations(issues: CurationIssue[], totalItems: number): string[] {\n    const recommendations: string[] = [];\n    \n    const errorCount = issues.filter(i => i.severity === 'error').length;\n    const warningCount = issues.filter(i => i.severity === 'warning').length;\n    \n    if (errorCount > totalItems * 0.1) {\n      recommendations.push('High error rate detected. Review content sources and validation processes.');\n    }\n    \n    if (warningCount > totalItems * 0.3) {\n      recommendations.push('Many items flagged with warnings. Consider additional quality review.');\n    }\n    \n    const commonIssues = this.getCommonIssues(issues);\n    if (commonIssues.length > 0) {\n      recommendations.push(`Common issues found: ${commonIssues.join(', ')}. Consider systematic fixes.`);\n    }\n    \n    return recommendations;\n  }\n\n  private getCommonIssues(issues: CurationIssue[]): string[] {\n    const issueCounts = new Map<string, number>();\n    \n    issues.forEach(issue => {\n      const count = issueCounts.get(issue.ruleId) || 0;\n      issueCounts.set(issue.ruleId, count + 1);\n    });\n    \n    return Array.from(issueCounts.entries())\n      .filter(([_, count]) => count >= 3)\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 3)\n      .map(([ruleId, _]) => this.rules.get(ruleId)?.name || ruleId);\n  }\n\n  private randomSample<T>(array: T[], size: number): T[] {\n    const shuffled = [...array].sort(() => 0.5 - Math.random());\n    return shuffled.slice(0, size);\n  }\n\n  // Public API methods\n  async getCurationRules(): Promise<CurationRule[]> {\n    return Array.from(this.rules.values());\n  }\n\n  async addCurationRule(rule: CurationRule): Promise<void> {\n    this.rules.set(rule.id, rule);\n  }\n\n  async removeCurationRule(ruleId: string): Promise<boolean> {\n    return this.rules.delete(ruleId);\n  }\n\n  async getQualityMetrics(): Promise<{\n    totalBatches: number;\n    averageQualityScore: number;\n    totalItemsProcessed: number;\n    approvalRate: number;\n  }> {\n    const batches = Array.from(this.batches.values()).filter(b => b.status === 'completed');\n    \n    if (batches.length === 0) {\n      return {\n        totalBatches: 0,\n        averageQualityScore: 0,\n        totalItemsProcessed: 0,\n        approvalRate: 0\n      };\n    }\n    \n    const totalItems = batches.reduce((sum, b) => sum + (b.results?.totalItems || 0), 0);\n    const totalApproved = batches.reduce((sum, b) => sum + (b.results?.approvedItems || 0), 0);\n    const avgQuality = batches.reduce((sum, b) => sum + (b.results?.qualityScore || 0), 0) / batches.length;\n    \n    return {\n      totalBatches: batches.length,\n      averageQualityScore: avgQuality,\n      totalItemsProcessed: totalItems,\n      approvalRate: totalItems > 0 ? totalApproved / totalItems : 0\n    };\n  }\n}\n\n// Export singleton instance\nexport const contentCurationService = new ContentCurationService();\n