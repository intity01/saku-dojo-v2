// Security Service\n// Comprehensive security measures for chat system\n\nimport type { ChatMessage, Conversation } from '../types/chat';\n\nexport interface SecurityConfig {\n  // Rate limiting\n  maxMessagesPerMinute: number;\n  maxMessagesPerHour: number;\n  maxFilesPerHour: number;\n  maxFileSize: number; // bytes\n  \n  // Content filtering\n  enableProfanityFilter: boolean;\n  enableSpamDetection: boolean;\n  enableMalwareScanning: boolean;\n  \n  // Authentication\n  requireAuthentication: boolean;\n  sessionTimeout: number; // minutes\n  maxConcurrentSessions: number;\n  \n  // Encryption\n  encryptMessages: boolean;\n  encryptFiles: boolean;\n  \n  // Audit logging\n  enableAuditLog: boolean;\n  auditLogRetentionDays: number;\n}\n\nexport interface RateLimitStatus {\n  userId: string;\n  messagesThisMinute: number;\n  messagesThisHour: number;\n  filesThisHour: number;\n  lastMessageAt: Date;\n  lastFileAt: Date;\n  blocked: boolean;\n  blockUntil?: Date;\n}\n\nexport interface SecurityEvent {\n  id: string;\n  type: 'rate_limit' | 'content_filter' | 'malware_detected' | 'auth_failure' | 'suspicious_activity';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  userId?: string;\n  sessionId?: string;\n  conversationId?: string;\n  messageId?: string;\n  description: string;\n  metadata: Record<string, any>;\n  timestamp: string;\n  resolved: boolean;\n  resolvedAt?: string;\n}\n\nexport interface ContentFilterResult {\n  allowed: boolean;\n  confidence: number; // 0-1\n  reasons: string[];\n  filteredContent?: string;\n  categories: string[];\n}\n\nexport interface MalwareScanResult {\n  safe: boolean;\n  threats: string[];\n  scanTime: number;\n  scanner: string;\n  signature?: string;\n}\n\nexport class SecurityService {\n  private config: SecurityConfig;\n  private rateLimits: Map<string, RateLimitStatus> = new Map();\n  private securityEvents: SecurityEvent[] = [];\n  private blockedUsers: Set<string> = new Set();\n  private suspiciousIPs: Set<string> = new Set();\n  \n  // Content filters\n  private profanityWords: Set<string> = new Set();\n  private spamPatterns: RegExp[] = [];\n  \n  constructor(config?: Partial<SecurityConfig>) {\n    this.config = {\n      maxMessagesPerMinute: 10,\n      maxMessagesPerHour: 100,\n      maxFilesPerHour: 20,\n      maxFileSize: 10 * 1024 * 1024, // 10MB\n      enableProfanityFilter: true,\n      enableSpamDetection: true,\n      enableMalwareScanning: true,\n      requireAuthentication: false,\n      sessionTimeout: 60,\n      maxConcurrentSessions: 3,\n      encryptMessages: false,\n      encryptFiles: true,\n      enableAuditLog: true,\n      auditLogRetentionDays: 90,\n      ...config\n    };\n    \n    this.initializeFilters();\n  }\n\n  private initializeFilters(): void {\n    // Initialize profanity filter\n    this.profanityWords = new Set([\n      // Thai profanity (simplified list)\n      'ไอ้', 'เหี้ย', 'ควาย', 'บ้า',\n      // English profanity (simplified list)\n      'damn', 'hell', 'shit', 'fuck', 'bitch'\n    ]);\n    \n    // Initialize spam patterns\n    this.spamPatterns = [\n      /https?:\\/\\/[^\\s]+/gi, // URLs\n      /\\b\\d{10,}\\b/g, // Long numbers (phone numbers)\n      /(..)\\1{3,}/g, // Repeated characters\n      /[A-Z]{5,}/g, // All caps words\n      /\\$\\d+|\\d+\\$|฿\\d+|\\d+฿/g // Money amounts\n    ];\n  }\n\n  // Rate Limiting\n  async checkRateLimit(\n    userId: string,\n    type: 'message' | 'file' = 'message'\n  ): Promise<{ allowed: boolean; reason?: string; retryAfter?: number }> {\n    const now = new Date();\n    const status = this.rateLimits.get(userId) || {\n      userId,\n      messagesThisMinute: 0,\n      messagesThisHour: 0,\n      filesThisHour: 0,\n      lastMessageAt: new Date(0),\n      lastFileAt: new Date(0),\n      blocked: false\n    };\n\n    // Check if user is blocked\n    if (status.blocked && status.blockUntil && now < status.blockUntil) {\n      const retryAfter = Math.ceil((status.blockUntil.getTime() - now.getTime()) / 1000);\n      return { allowed: false, reason: 'User temporarily blocked', retryAfter };\n    }\n\n    // Reset counters if needed\n    const minuteAgo = new Date(now.getTime() - 60 * 1000);\n    const hourAgo = new Date(now.getTime() - 60 * 60 * 1000);\n    \n    if (status.lastMessageAt < minuteAgo) {\n      status.messagesThisMinute = 0;\n    }\n    \n    if (status.lastMessageAt < hourAgo) {\n      status.messagesThisHour = 0;\n    }\n    \n    if (status.lastFileAt < hourAgo) {\n      status.filesThisHour = 0;\n    }\n\n    // Check limits\n    if (type === 'message') {\n      if (status.messagesThisMinute >= this.config.maxMessagesPerMinute) {\n        this.logSecurityEvent('rate_limit', 'medium', userId, 'Messages per minute exceeded');\n        return { allowed: false, reason: 'Too many messages per minute', retryAfter: 60 };\n      }\n      \n      if (status.messagesThisHour >= this.config.maxMessagesPerHour) {\n        this.logSecurityEvent('rate_limit', 'high', userId, 'Messages per hour exceeded');\n        status.blocked = true;\n        status.blockUntil = new Date(now.getTime() + 60 * 60 * 1000); // Block for 1 hour\n        return { allowed: false, reason: 'Too many messages per hour', retryAfter: 3600 };\n      }\n      \n      // Update counters\n      status.messagesThisMinute++;\n      status.messagesThisHour++;\n      status.lastMessageAt = now;\n      \n    } else if (type === 'file') {\n      if (status.filesThisHour >= this.config.maxFilesPerHour) {\n        this.logSecurityEvent('rate_limit', 'medium', userId, 'Files per hour exceeded');\n        return { allowed: false, reason: 'Too many files per hour', retryAfter: 3600 };\n      }\n      \n      status.filesThisHour++;\n      status.lastFileAt = now;\n    }\n\n    this.rateLimits.set(userId, status);\n    return { allowed: true };\n  }\n\n  // Content Filtering\n  async filterContent(content: string, userId?: string): Promise<ContentFilterResult> {\n    const result: ContentFilterResult = {\n      allowed: true,\n      confidence: 1.0,\n      reasons: [],\n      categories: []\n    };\n\n    if (!this.config.enableProfanityFilter && !this.config.enableSpamDetection) {\n      return result;\n    }\n\n    const lowerContent = content.toLowerCase();\n    \n    // Profanity detection\n    if (this.config.enableProfanityFilter) {\n      const profanityFound = Array.from(this.profanityWords).filter(word => \n        lowerContent.includes(word.toLowerCase())\n      );\n      \n      if (profanityFound.length > 0) {\n        result.allowed = false;\n        result.confidence = 0.9;\n        result.reasons.push('Profanity detected');\n        result.categories.push('profanity');\n        result.filteredContent = this.filterProfanity(content);\n        \n        if (userId) {\n          this.logSecurityEvent('content_filter', 'medium', userId, `Profanity detected: ${profanityFound.join(', ')}`);\n        }\n      }\n    }\n\n    // Spam detection\n    if (this.config.enableSpamDetection) {\n      const spamScore = this.calculateSpamScore(content);\n      \n      if (spamScore > 0.7) {\n        result.allowed = false;\n        result.confidence = spamScore;\n        result.reasons.push('Spam detected');\n        result.categories.push('spam');\n        \n        if (userId) {\n          this.logSecurityEvent('content_filter', 'medium', userId, `Spam detected (score: ${spamScore})`);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private filterProfanity(content: string): string {\n    let filtered = content;\n    \n    this.profanityWords.forEach(word => {\n      const regex = new RegExp(word, 'gi');\n      filtered = filtered.replace(regex, '*'.repeat(word.length));\n    });\n    \n    return filtered;\n  }\n\n  private calculateSpamScore(content: string): number {\n    let score = 0;\n    \n    // Check against spam patterns\n    this.spamPatterns.forEach(pattern => {\n      const matches = content.match(pattern);\n      if (matches) {\n        score += matches.length * 0.2;\n      }\n    });\n    \n    // Check for excessive repetition\n    const words = content.split(/\\s+/);\n    const uniqueWords = new Set(words.map(w => w.toLowerCase()));\n    const repetitionRatio = 1 - (uniqueWords.size / words.length);\n    score += repetitionRatio * 0.5;\n    \n    // Check for excessive capitalization\n    const capsRatio = (content.match(/[A-Z]/g) || []).length / content.length;\n    if (capsRatio > 0.5) {\n      score += 0.3;\n    }\n    \n    return Math.min(1, score);\n  }\n\n  // File Security\n  async scanFile(file: File): Promise<MalwareScanResult> {\n    if (!this.config.enableMalwareScanning) {\n      return {\n        safe: true,\n        threats: [],\n        scanTime: 0,\n        scanner: 'disabled'\n      };\n    }\n\n    const startTime = Date.now();\n    \n    try {\n      // Simulate malware scanning\n      // In a real implementation, you'd integrate with a service like VirusTotal\n      const threats: string[] = [];\n      \n      // Basic file type validation\n      const dangerousExtensions = ['.exe', '.bat', '.cmd', '.scr', '.pif', '.com'];\n      const fileExtension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));\n      \n      if (dangerousExtensions.includes(fileExtension)) {\n        threats.push(`Potentially dangerous file type: ${fileExtension}`);\n      }\n      \n      // File size validation\n      if (file.size > this.config.maxFileSize) {\n        threats.push(`File too large: ${file.size} bytes (max: ${this.config.maxFileSize})`);\n      }\n      \n      const scanTime = Date.now() - startTime;\n      const safe = threats.length === 0;\n      \n      if (!safe) {\n        this.logSecurityEvent('malware_detected', 'high', undefined, `File scan failed: ${threats.join(', ')}`, {\n          filename: file.name,\n          fileSize: file.size,\n          mimeType: file.type\n        });\n      }\n      \n      return {\n        safe,\n        threats,\n        scanTime,\n        scanner: 'saku-dojo-scanner-v1',\n        signature: safe ? 'clean' : 'threat_detected'\n      };\n      \n    } catch (error) {\n      this.logSecurityEvent('malware_detected', 'critical', undefined, `File scan error: ${error}`);\n      \n      return {\n        safe: false,\n        threats: ['Scan failed'],\n        scanTime: Date.now() - startTime,\n        scanner: 'error'\n      };\n    }\n  }\n\n  // Input Validation\n  validateMessage(message: Partial<ChatMessage>): {\n    valid: boolean;\n    errors: string[];\n    sanitized?: Partial<ChatMessage>;\n  } {\n    const errors: string[] = [];\n    const sanitized = { ...message };\n\n    // Required fields\n    if (!message.content || message.content.trim().length === 0) {\n      errors.push('Message content is required');\n    }\n    \n    if (!message.conversationId) {\n      errors.push('Conversation ID is required');\n    }\n    \n    if (!message.senderId) {\n      errors.push('Sender ID is required');\n    }\n\n    // Content validation\n    if (message.content) {\n      // Length validation\n      if (message.content.length > 4000) {\n        errors.push('Message too long (max 4000 characters)');\n      }\n      \n      // Sanitize content\n      sanitized.content = this.sanitizeContent(message.content);\n    }\n\n    // Type validation\n    const validTypes = ['text', 'image', 'file', 'system', 'quick_reply', 'form'];\n    if (message.type && !validTypes.includes(message.type)) {\n      errors.push('Invalid message type');\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      sanitized: errors.length === 0 ? sanitized : undefined\n    };\n  }\n\n  private sanitizeContent(content: string): string {\n    // Remove potentially dangerous HTML/script tags\n    let sanitized = content\n      .replace(/<script[^>]*>.*?<\\/script>/gi, '')\n      .replace(/<iframe[^>]*>.*?<\\/iframe>/gi, '')\n      .replace(/javascript:/gi, '')\n      .replace(/on\\w+\\s*=/gi, '');\n    \n    // Normalize whitespace\n    sanitized = sanitized.replace(/\\s+/g, ' ').trim();\n    \n    return sanitized;\n  }\n\n  // Authentication & Session Management\n  async validateSession(sessionId: string): Promise<{\n    valid: boolean;\n    expired: boolean;\n    userId?: string;\n    expiresAt?: Date;\n  }> {\n    // In a real implementation, you'd validate against a session store\n    // For now, we'll simulate session validation\n    \n    if (!sessionId || sessionId.length < 10) {\n      return { valid: false, expired: false };\n    }\n    \n    // Simulate session lookup\n    const sessionData = {\n      userId: 'user_123',\n      createdAt: new Date(Date.now() - 30 * 60 * 1000), // 30 minutes ago\n      expiresAt: new Date(Date.now() + 30 * 60 * 1000) // 30 minutes from now\n    };\n    \n    const expired = sessionData.expiresAt < new Date();\n    \n    return {\n      valid: !expired,\n      expired,\n      userId: sessionData.userId,\n      expiresAt: sessionData.expiresAt\n    };\n  }\n\n  async createSession(userId: string): Promise<{\n    sessionId: string;\n    expiresAt: Date;\n    token?: string;\n  }> {\n    const sessionId = `sess_${Date.now()}_${Math.random().toString(36).substr(2, 16)}`;\n    const expiresAt = new Date(Date.now() + this.config.sessionTimeout * 60 * 1000);\n    \n    // In a real implementation, you'd store this in Redis or database\n    console.log(`[Security] Session created for user ${userId}: ${sessionId}`);\n    \n    return {\n      sessionId,\n      expiresAt,\n      token: this.generateSecureToken()\n    };\n  }\n\n  private generateSecureToken(): string {\n    // Generate a secure random token\n    const array = new Uint8Array(32);\n    crypto.getRandomValues(array);\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  // Security Event Logging\n  private logSecurityEvent(\n    type: SecurityEvent['type'],\n    severity: SecurityEvent['severity'],\n    userId?: string,\n    description: string = '',\n    metadata: Record<string, any> = {}\n  ): void {\n    const event: SecurityEvent = {\n      id: `sec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      type,\n      severity,\n      userId,\n      description,\n      metadata: {\n        ...metadata,\n        userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      resolved: false\n    };\n\n    this.securityEvents.push(event);\n    \n    // Keep only recent events in memory\n    if (this.securityEvents.length > 1000) {\n      this.securityEvents = this.securityEvents.slice(-500);\n    }\n    \n    // Log to console for development\n    console.warn(`[Security] ${severity.toUpperCase()} - ${type}: ${description}`, metadata);\n    \n    // In production, you'd send to a security monitoring service\n    if (severity === 'critical') {\n      this.handleCriticalSecurityEvent(event);\n    }\n  }\n\n  private async handleCriticalSecurityEvent(event: SecurityEvent): Promise<void> {\n    // In a real implementation, you'd:\n    // 1. Send immediate alerts to security team\n    // 2. Potentially block the user/IP\n    // 3. Create incident ticket\n    // 4. Log to SIEM system\n    \n    console.error('[Security] CRITICAL EVENT:', event);\n    \n    if (event.userId) {\n      this.blockedUsers.add(event.userId);\n    }\n  }\n\n  // User & IP Management\n  blockUser(userId: string, reason: string, durationMinutes: number = 60): void {\n    this.blockedUsers.add(userId);\n    \n    const status = this.rateLimits.get(userId) || {\n      userId,\n      messagesThisMinute: 0,\n      messagesThisHour: 0,\n      filesThisHour: 0,\n      lastMessageAt: new Date(),\n      lastFileAt: new Date(),\n      blocked: false\n    };\n    \n    status.blocked = true;\n    status.blockUntil = new Date(Date.now() + durationMinutes * 60 * 1000);\n    this.rateLimits.set(userId, status);\n    \n    this.logSecurityEvent('suspicious_activity', 'high', userId, `User blocked: ${reason}`);\n  }\n\n  unblockUser(userId: string): void {\n    this.blockedUsers.delete(userId);\n    \n    const status = this.rateLimits.get(userId);\n    if (status) {\n      status.blocked = false;\n      status.blockUntil = undefined;\n      this.rateLimits.set(userId, status);\n    }\n    \n    console.log(`[Security] User unblocked: ${userId}`);\n  }\n\n  isUserBlocked(userId: string): boolean {\n    const status = this.rateLimits.get(userId);\n    if (!status || !status.blocked) {\n      return false;\n    }\n    \n    // Check if block has expired\n    if (status.blockUntil && new Date() > status.blockUntil) {\n      this.unblockUser(userId);\n      return false;\n    }\n    \n    return true;\n  }\n\n  // Security Analytics\n  getSecurityMetrics(): {\n    totalEvents: number;\n    eventsBySeverity: Record<string, number>;\n    eventsByType: Record<string, number>;\n    blockedUsers: number;\n    rateLimitHits: number;\n    lastEvent?: SecurityEvent;\n  } {\n    const eventsBySeverity = this.securityEvents.reduce((acc, event) => {\n      acc[event.severity] = (acc[event.severity] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n    \n    const eventsByType = this.securityEvents.reduce((acc, event) => {\n      acc[event.type] = (acc[event.type] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n    \n    const rateLimitHits = this.securityEvents.filter(e => e.type === 'rate_limit').length;\n    const lastEvent = this.securityEvents[this.securityEvents.length - 1];\n    \n    return {\n      totalEvents: this.securityEvents.length,\n      eventsBySeverity,\n      eventsByType,\n      blockedUsers: this.blockedUsers.size,\n      rateLimitHits,\n      lastEvent\n    };\n  }\n\n  getSecurityEvents(\n    severity?: SecurityEvent['severity'],\n    type?: SecurityEvent['type'],\n    limit: number = 100\n  ): SecurityEvent[] {\n    let events = [...this.securityEvents];\n    \n    if (severity) {\n      events = events.filter(e => e.severity === severity);\n    }\n    \n    if (type) {\n      events = events.filter(e => e.type === type);\n    }\n    \n    return events\n      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())\n      .slice(0, limit);\n  }\n\n  // Configuration\n  updateConfig(newConfig: Partial<SecurityConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    console.log('[Security] Configuration updated');\n  }\n\n  getConfig(): SecurityConfig {\n    return { ...this.config };\n  }\n\n  // Health Check\n  async healthCheck(): Promise<{\n    status: 'healthy' | 'degraded' | 'unhealthy';\n    details: Record<string, any>;\n  }> {\n    const metrics = this.getSecurityMetrics();\n    const recentCriticalEvents = this.getSecurityEvents('critical', undefined, 10);\n    const recentHighEvents = this.getSecurityEvents('high', undefined, 50);\n    \n    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n    \n    // Check for critical events in last hour\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n    const recentCritical = recentCriticalEvents.filter(e => new Date(e.timestamp) > oneHourAgo);\n    \n    if (recentCritical.length > 0) {\n      status = 'unhealthy';\n    } else if (recentHighEvents.length > 10) {\n      status = 'degraded';\n    }\n    \n    return {\n      status,\n      details: {\n        ...metrics,\n        recentCriticalEvents: recentCritical.length,\n        recentHighEvents: recentHighEvents.length,\n        config: {\n          rateLimiting: {\n            maxMessagesPerMinute: this.config.maxMessagesPerMinute,\n            maxMessagesPerHour: this.config.maxMessagesPerHour\n          },\n          contentFiltering: {\n            profanityFilter: this.config.enableProfanityFilter,\n            spamDetection: this.config.enableSpamDetection\n          },\n          fileScanning: {\n            malwareScanning: this.config.enableMalwareScanning,\n            maxFileSize: this.config.maxFileSize\n          }\n        },\n        timestamp: new Date().toISOString()\n      }\n    };\n  }\n\n  // Cleanup\n  async cleanup(): Promise<void> {\n    // Clean up old rate limit data\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n    \n    for (const [userId, status] of this.rateLimits.entries()) {\n      if (status.lastMessageAt < oneHourAgo && status.lastFileAt < oneHourAgo && !status.blocked) {\n        this.rateLimits.delete(userId);\n      }\n    }\n    \n    // Clean up old security events\n    const retentionDate = new Date(Date.now() - this.config.auditLogRetentionDays * 24 * 60 * 60 * 1000);\n    this.securityEvents = this.securityEvents.filter(e => new Date(e.timestamp) > retentionDate);\n    \n    console.log('[Security] Cleanup completed');\n  }\n}\n\n// Export singleton instance\nexport const securityService = new SecurityService();\n