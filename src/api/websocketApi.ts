// WebSocket API Design\n// Real-time WebSocket API with comprehensive event handling\n\nimport type {\n  WebSocketEvent,\n  WebSocketEventType,\n  ChatMessage,\n  Conversation,\n  TypingIndicator\n} from '../types/chat';\nimport { websocketService } from '../services/websocketService';\n\n// WebSocket API Configuration\nexport const WS_API_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:3001/ws';\nexport const WS_API_VERSION = 'v1';\n\n// Event Payload Types\nexport interface MessageSentEvent {\n  message: ChatMessage;\n  conversation: Conversation;\n}\n\nexport interface MessageReceivedEvent {\n  message: ChatMessage;\n  channel: string;\n}\n\nexport interface MessageUpdatedEvent {\n  messageId: string;\n  updates: Partial<ChatMessage>;\n  conversationId: string;\n}\n\nexport interface MessageDeletedEvent {\n  messageId: string;\n  conversationId: string;\n  deletedBy: string;\n}\n\nexport interface TypingStartEvent {\n  conversationId: string;\n  userId: string;\n  userName: string;\n  timestamp: string;\n}\n\nexport interface TypingStopEvent {\n  conversationId: string;\n  userId: string;\n  timestamp: string;\n}\n\nexport interface UserJoinedEvent {\n  conversationId: string;\n  userId: string;\n  userName: string;\n  role: string;\n  timestamp: string;\n}\n\nexport interface UserLeftEvent {\n  conversationId: string;\n  userId: string;\n  timestamp: string;\n}\n\nexport interface ConversationUpdatedEvent {\n  conversation: Conversation;\n  updatedFields: string[];\n  updatedBy: string;\n}\n\nexport interface ConnectionStatusEvent {\n  connected: boolean;\n  latency?: number;\n  reconnectAttempts?: number;\n  error?: string;\n  timestamp: string;\n}\n\nexport interface ErrorEvent {\n  code: string;\n  message: string;\n  details?: any;\n  conversationId?: string;\n  messageId?: string;\n  timestamp: string;\n}\n\n// WebSocket API Service\nexport class WebSocketApiService {\n  private ws: typeof websocketService;\n  private eventHandlers: Map<WebSocketEventType, ((data: any) => void)[]> = new Map();\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor() {\n    this.ws = websocketService;\n    this.setupEventHandlers();\n  }\n\n  // Connection Management\n  async connect(url?: string): Promise<void> {\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    this.connectionPromise = this.ws.connect();\n    return this.connectionPromise;\n  }\n\n  disconnect(): void {\n    this.ws.disconnect();\n    this.connectionPromise = null;\n  }\n\n  isConnected(): boolean {\n    return this.ws.getStatus().connected;\n  }\n\n  getConnectionStatus(): {\n    connected: boolean;\n    latency?: number;\n    reconnectAttempts: number;\n    error?: string;\n  } {\n    return this.ws.getStatus();\n  }\n\n  // Event Handling\n  private setupEventHandlers(): void {\n    // Set up WebSocket service event listeners\n    this.ws.addEventListener('message_sent', (data) => {\n      this.emitEvent('message_sent', data);\n    });\n\n    this.ws.addEventListener('message_received', (data) => {\n      this.emitEvent('message_received', data);\n    });\n\n    this.ws.addEventListener('message_updated', (data) => {\n      this.emitEvent('message_updated', data);\n    });\n\n    this.ws.addEventListener('message_deleted', (data) => {\n      this.emitEvent('message_deleted', data);\n    });\n\n    this.ws.addEventListener('typing_start', (data) => {\n      this.emitEvent('typing_start', data);\n    });\n\n    this.ws.addEventListener('typing_stop', (data) => {\n      this.emitEvent('typing_stop', data);\n    });\n\n    this.ws.addEventListener('user_joined', (data) => {\n      this.emitEvent('user_joined', data);\n    });\n\n    this.ws.addEventListener('user_left', (data) => {\n      this.emitEvent('user_left', data);\n    });\n\n    this.ws.addEventListener('conversation_updated', (data) => {\n      this.emitEvent('conversation_updated', data);\n    });\n\n    this.ws.addEventListener('connection_status', (data) => {\n      this.emitEvent('connection_status', data);\n    });\n\n    this.ws.addEventListener('error', (data) => {\n      this.emitEvent('error', data);\n    });\n  }\n\n  private emitEvent(type: WebSocketEventType, data: any): void {\n    const handlers = this.eventHandlers.get(type);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(data);\n        } catch (error) {\n          console.error(`[WebSocketApi] Event handler error for ${type}:`, error);\n        }\n      });\n    }\n  }\n\n  // Event Subscription\n  on<T = any>(event: WebSocketEventType, handler: (data: T) => void): () => void {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, []);\n    }\n    \n    this.eventHandlers.get(event)!.push(handler);\n    \n    // Return unsubscribe function\n    return () => {\n      const handlers = this.eventHandlers.get(event);\n      if (handlers) {\n        const index = handlers.indexOf(handler);\n        if (index > -1) {\n          handlers.splice(index, 1);\n        }\n      }\n    };\n  }\n\n  off(event: WebSocketEventType, handler?: (data: any) => void): void {\n    if (!handler) {\n      // Remove all handlers for this event\n      this.eventHandlers.delete(event);\n      return;\n    }\n\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      const index = handlers.indexOf(handler);\n      if (index > -1) {\n        handlers.splice(index, 1);\n      }\n    }\n  }\n\n  // Message Operations\n  async sendMessage(message: ChatMessage): Promise<void> {\n    await this.ws.sendMessage(message);\n  }\n\n  async updateMessage(\n    messageId: string,\n    conversationId: string,\n    updates: Partial<ChatMessage>\n  ): Promise<void> {\n    await this.ws.sendEvent({\n      type: 'message_updated',\n      data: {\n        messageId,\n        updates,\n        conversationId,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      conversationId\n    });\n  }\n\n  async deleteMessage(\n    messageId: string,\n    conversationId: string,\n    deletedBy: string\n  ): Promise<void> {\n    await this.ws.sendEvent({\n      type: 'message_deleted',\n      data: {\n        messageId,\n        conversationId,\n        deletedBy,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      conversationId\n    });\n  }\n\n  // Typing Indicators\n  async startTyping(\n    conversationId: string,\n    userId: string,\n    userName: string\n  ): Promise<void> {\n    await this.ws.sendTypingStart(conversationId, userId, userName);\n  }\n\n  async stopTyping(conversationId: string, userId: string): Promise<void> {\n    await this.ws.sendTypingStop(conversationId, userId);\n  }\n\n  // Conversation Operations\n  async joinConversation(\n    conversationId: string,\n    userId: string,\n    userName: string,\n    role: string = 'user'\n  ): Promise<void> {\n    await this.ws.sendEvent({\n      type: 'user_joined',\n      data: {\n        conversationId,\n        userId,\n        userName,\n        role,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      conversationId\n    });\n  }\n\n  async leaveConversation(conversationId: string, userId: string): Promise<void> {\n    await this.ws.leaveConversation(conversationId, userId);\n  }\n\n  async updateConversation(\n    conversation: Conversation,\n    updatedFields: string[],\n    updatedBy: string\n  ): Promise<void> {\n    await this.ws.sendEvent({\n      type: 'conversation_updated',\n      data: {\n        conversation,\n        updatedFields,\n        updatedBy,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      conversationId: conversation.id\n    });\n  }\n\n  // Presence Management\n  async setPresence(\n    conversationId: string,\n    userId: string,\n    status: 'online' | 'away' | 'offline'\n  ): Promise<void> {\n    await this.ws.sendEvent({\n      type: 'user_joined', // Reuse for presence updates\n      data: {\n        conversationId,\n        userId,\n        status,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      conversationId\n    });\n  }\n\n  // Reaction Operations\n  async addReaction(\n    messageId: string,\n    conversationId: string,\n    emoji: string,\n    userId: string,\n    userName: string\n  ): Promise<void> {\n    await this.ws.sendEvent({\n      type: 'message_updated',\n      data: {\n        messageId,\n        conversationId,\n        action: 'add_reaction',\n        emoji,\n        userId,\n        userName,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      conversationId\n    });\n  }\n\n  async removeReaction(\n    messageId: string,\n    conversationId: string,\n    emoji: string,\n    userId: string\n  ): Promise<void> {\n    await this.ws.sendEvent({\n      type: 'message_updated',\n      data: {\n        messageId,\n        conversationId,\n        action: 'remove_reaction',\n        emoji,\n        userId,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      conversationId\n    });\n  }\n\n  // Read Status\n  async markAsRead(\n    messageId: string,\n    conversationId: string,\n    userId: string,\n    userName: string\n  ): Promise<void> {\n    await this.ws.sendEvent({\n      type: 'message_updated',\n      data: {\n        messageId,\n        conversationId,\n        action: 'mark_read',\n        userId,\n        userName,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString(),\n      conversationId\n    });\n  }\n\n  // Utility Methods\n  async ping(): Promise<number> {\n    const startTime = Date.now();\n    \n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Ping timeout'));\n      }, 5000);\n\n      const unsubscribe = this.on('connection_status', (data) => {\n        if (data.type === 'pong') {\n          clearTimeout(timeout);\n          unsubscribe();\n          resolve(Date.now() - startTime);\n        }\n      });\n\n      this.ws.sendEvent({\n        type: 'connection_status',\n        data: { type: 'ping', timestamp: new Date().toISOString() },\n        timestamp: new Date().toISOString()\n      }).catch(reject);\n    });\n  }\n\n  getMetrics(): {\n    connected: boolean;\n    latency?: number;\n    queuedMessages: number;\n    reconnectAttempts: number;\n    uptime?: number;\n  } {\n    return this.ws.getMetrics();\n  }\n\n  // Health Check\n  async healthCheck(): Promise<{\n    status: 'healthy' | 'degraded' | 'unhealthy';\n    details: Record<string, any>;\n  }> {\n    return this.ws.healthCheck();\n  }\n\n  // Cleanup\n  cleanup(): void {\n    this.eventHandlers.clear();\n    this.ws.cleanup();\n    this.connectionPromise = null;\n  }\n}\n\n// WebSocket Event Types for Type Safety\nexport const WS_EVENTS = {\n  // Message events\n  MESSAGE_SENT: 'message_sent' as const,\n  MESSAGE_RECEIVED: 'message_received' as const,\n  MESSAGE_UPDATED: 'message_updated' as const,\n  MESSAGE_DELETED: 'message_deleted' as const,\n  \n  // Typing events\n  TYPING_START: 'typing_start' as const,\n  TYPING_STOP: 'typing_stop' as const,\n  \n  // User events\n  USER_JOINED: 'user_joined' as const,\n  USER_LEFT: 'user_left' as const,\n  \n  // Conversation events\n  CONVERSATION_UPDATED: 'conversation_updated' as const,\n  \n  // System events\n  CONNECTION_STATUS: 'connection_status' as const,\n  ERROR: 'error' as const\n} as const;\n\n// Event Handler Types\nexport type EventHandlers = {\n  [WS_EVENTS.MESSAGE_SENT]: (data: MessageSentEvent) => void;\n  [WS_EVENTS.MESSAGE_RECEIVED]: (data: MessageReceivedEvent) => void;\n  [WS_EVENTS.MESSAGE_UPDATED]: (data: MessageUpdatedEvent) => void;\n  [WS_EVENTS.MESSAGE_DELETED]: (data: MessageDeletedEvent) => void;\n  [WS_EVENTS.TYPING_START]: (data: TypingStartEvent) => void;\n  [WS_EVENTS.TYPING_STOP]: (data: TypingStopEvent) => void;\n  [WS_EVENTS.USER_JOINED]: (data: UserJoinedEvent) => void;\n  [WS_EVENTS.USER_LEFT]: (data: UserLeftEvent) => void;\n  [WS_EVENTS.CONVERSATION_UPDATED]: (data: ConversationUpdatedEvent) => void;\n  [WS_EVENTS.CONNECTION_STATUS]: (data: ConnectionStatusEvent) => void;\n  [WS_EVENTS.ERROR]: (data: ErrorEvent) => void;\n};\n\n// Utility Functions\nexport function createWebSocketUrl(baseUrl: string, params?: Record<string, string>): string {\n  const url = new URL(baseUrl);\n  \n  if (params) {\n    Object.entries(params).forEach(([key, value]) => {\n      url.searchParams.append(key, value);\n    });\n  }\n  \n  return url.toString();\n}\n\nexport function isWebSocketSupported(): boolean {\n  return typeof WebSocket !== 'undefined';\n}\n\nexport function getWebSocketReadyState(ws: WebSocket | null): string {\n  if (!ws) return 'CLOSED';\n  \n  switch (ws.readyState) {\n    case WebSocket.CONNECTING:\n      return 'CONNECTING';\n    case WebSocket.OPEN:\n      return 'OPEN';\n    case WebSocket.CLOSING:\n      return 'CLOSING';\n    case WebSocket.CLOSED:\n      return 'CLOSED';\n    default:\n      return 'UNKNOWN';\n  }\n}\n\n// Export singleton instance\nexport const wsApi = new WebSocketApiService();\n\n// React Hook for WebSocket Events\nexport function useWebSocketEvent<T extends keyof EventHandlers>(\n  event: T,\n  handler: EventHandlers[T],\n  deps: React.DependencyList = []\n): void {\n  React.useEffect(() => {\n    const unsubscribe = wsApi.on(event, handler);\n    return unsubscribe;\n  }, deps);\n}\n\n// React Hook for WebSocket Connection\nexport function useWebSocketConnection(): {\n  connected: boolean;\n  connecting: boolean;\n  error?: string;\n  latency?: number;\n  connect: () => Promise<void>;\n  disconnect: () => void;\n} {\n  const [status, setStatus] = React.useState(() => wsApi.getConnectionStatus());\n  const [connecting, setConnecting] = React.useState(false);\n\n  React.useEffect(() => {\n    const unsubscribe = wsApi.on('connection_status', (data) => {\n      setStatus({\n        connected: data.connected,\n        latency: data.latency,\n        reconnectAttempts: data.reconnectAttempts || 0,\n        error: data.error\n      });\n      setConnecting(false);\n    });\n\n    return unsubscribe;\n  }, []);\n\n  const connect = React.useCallback(async () => {\n    setConnecting(true);\n    try {\n      await wsApi.connect();\n    } catch (error) {\n      setConnecting(false);\n      throw error;\n    }\n  }, []);\n\n  const disconnect = React.useCallback(() => {\n    wsApi.disconnect();\n    setConnecting(false);\n  }, []);\n\n  return {\n    connected: status.connected,\n    connecting,\n    error: status.error,\n    latency: status.latency,\n    connect,\n    disconnect\n  };\n}\n