// Chat API Design\n// RESTful API endpoints for chat system with comprehensive CRUD operations\n\nimport type {\n  ChatMessage,\n  Conversation,\n  SendMessageRequest,\n  SendMessageResponse,\n  GetMessagesRequest,\n  GetMessagesResponse,\n  ChatApiResponse,\n  ConversationFilter,\n  MessageFilter,\n  ChatAnalytics\n} from '../types/chat';\n\n// API Base Configuration\nexport const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\nexport const API_VERSION = 'v1';\nexport const CHAT_API_BASE = `${API_BASE_URL}/${API_VERSION}/chat`;\n\n// Request/Response Types\nexport interface CreateConversationRequest {\n  title: string;\n  description?: string;\n  priority?: 'low' | 'normal' | 'high' | 'urgent';\n  category?: string;\n  tags?: string[];\n  channels?: string[];\n  userInfo?: {\n    userId?: string;\n    email?: string;\n    name?: string;\n    phone?: string;\n    language?: string;\n  };\n  context?: {\n    currentPage?: string;\n    currentFeature?: string;\n    userAction?: string;\n    errorCode?: string;\n    errorMessage?: string;\n    customData?: Record<string, any>;\n  };\n}\n\nexport interface UpdateConversationRequest {\n  title?: string;\n  description?: string;\n  status?: 'new' | 'open' | 'waiting' | 'resolved' | 'closed';\n  priority?: 'low' | 'normal' | 'high' | 'urgent';\n  category?: string;\n  tags?: string[];\n  assignedAgentId?: string;\n  satisfactionRating?: number;\n  satisfactionFeedback?: string;\n}\n\nexport interface UploadFileRequest {\n  conversationId: string;\n  file: File;\n  description?: string;\n}\n\nexport interface UploadFileResponse {\n  attachmentId: string;\n  filename: string;\n  size: number;\n  mimeType: string;\n  url: string;\n  thumbnailUrl?: string;\n}\n\nexport interface WebhookRequest {\n  channelType: string;\n  payload: any;\n  signature?: string;\n}\n\nexport interface WebhookResponse {\n  success: boolean;\n  messageId?: string;\n  conversationId?: string;\n  error?: string;\n}\n\nexport interface AnalyticsRequest {\n  startDate: string;\n  endDate: string;\n  granularity?: 'hour' | 'day' | 'week' | 'month';\n  channels?: string[];\n  includeDetails?: boolean;\n}\n\n// Chat API Service Class\nexport class ChatApiService {\n  private baseUrl: string;\n  private headers: Record<string, string>;\n\n  constructor(baseUrl: string = CHAT_API_BASE) {\n    this.baseUrl = baseUrl;\n    this.headers = {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json'\n    };\n  }\n\n  // Set authentication token\n  setAuthToken(token: string): void {\n    this.headers['Authorization'] = `Bearer ${token}`;\n  }\n\n  // Generic request method\n  private async request<T>(\n    endpoint: string,\n    options: RequestInit = {}\n  ): Promise<ChatApiResponse<T>> {\n    const url = `${this.baseUrl}${endpoint}`;\n    \n    const config: RequestInit = {\n      ...options,\n      headers: {\n        ...this.headers,\n        ...options.headers\n      }\n    };\n\n    try {\n      const response = await fetch(url, config);\n      const data = await response.json();\n\n      if (!response.ok) {\n        return {\n          success: false,\n          error: {\n            code: response.status.toString(),\n            message: data.message || response.statusText,\n            details: data.details\n          },\n          timestamp: new Date().toISOString()\n        };\n      }\n\n      return {\n        success: true,\n        data,\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          code: 'NETWORK_ERROR',\n          message: error instanceof Error ? error.message : 'Network error',\n          details: error\n        },\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n\n  // Conversation Management\n  async createConversation(request: CreateConversationRequest): Promise<ChatApiResponse<Conversation>> {\n    return this.request<Conversation>('/conversations', {\n      method: 'POST',\n      body: JSON.stringify(request)\n    });\n  }\n\n  async getConversation(conversationId: string): Promise<ChatApiResponse<Conversation>> {\n    return this.request<Conversation>(`/conversations/${conversationId}`);\n  }\n\n  async updateConversation(\n    conversationId: string,\n    request: UpdateConversationRequest\n  ): Promise<ChatApiResponse<Conversation>> {\n    return this.request<Conversation>(`/conversations/${conversationId}`, {\n      method: 'PATCH',\n      body: JSON.stringify(request)\n    });\n  }\n\n  async deleteConversation(conversationId: string): Promise<ChatApiResponse<void>> {\n    return this.request<void>(`/conversations/${conversationId}`, {\n      method: 'DELETE'\n    });\n  }\n\n  async getConversations(\n    filters?: ConversationFilter,\n    page: number = 1,\n    limit: number = 20\n  ): Promise<ChatApiResponse<{\n    conversations: Conversation[];\n    total: number;\n    page: number;\n    limit: number;\n    hasMore: boolean;\n  }>> {\n    const params = new URLSearchParams({\n      page: page.toString(),\n      limit: limit.toString()\n    });\n\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          if (Array.isArray(value)) {\n            value.forEach(v => params.append(key, v.toString()));\n          } else {\n            params.append(key, value.toString());\n          }\n        }\n      });\n    }\n\n    return this.request<any>(`/conversations?${params.toString()}`);\n  }\n\n  // Message Management\n  async sendMessage(request: SendMessageRequest): Promise<ChatApiResponse<SendMessageResponse>> {\n    return this.request<SendMessageResponse>('/messages', {\n      method: 'POST',\n      body: JSON.stringify(request)\n    });\n  }\n\n  async getMessage(messageId: string): Promise<ChatApiResponse<ChatMessage>> {\n    return this.request<ChatMessage>(`/messages/${messageId}`);\n  }\n\n  async updateMessage(\n    messageId: string,\n    updates: { content?: string; metadata?: any }\n  ): Promise<ChatApiResponse<ChatMessage>> {\n    return this.request<ChatMessage>(`/messages/${messageId}`, {\n      method: 'PATCH',\n      body: JSON.stringify(updates)\n    });\n  }\n\n  async deleteMessage(messageId: string): Promise<ChatApiResponse<void>> {\n    return this.request<void>(`/messages/${messageId}`, {\n      method: 'DELETE'\n    });\n  }\n\n  async getMessages(request: GetMessagesRequest): Promise<ChatApiResponse<GetMessagesResponse>> {\n    const params = new URLSearchParams({\n      conversationId: request.conversationId\n    });\n\n    if (request.limit) params.append('limit', request.limit.toString());\n    if (request.before) params.append('before', request.before);\n    if (request.after) params.append('after', request.after);\n\n    return this.request<GetMessagesResponse>(`/messages?${params.toString()}`);\n  }\n\n  async searchMessages(\n    query: string,\n    filters?: MessageFilter,\n    page: number = 1,\n    limit: number = 20\n  ): Promise<ChatApiResponse<{\n    messages: ChatMessage[];\n    total: number;\n    page: number;\n    limit: number;\n    hasMore: boolean;\n  }>> {\n    const params = new URLSearchParams({\n      q: query,\n      page: page.toString(),\n      limit: limit.toString()\n    });\n\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          if (Array.isArray(value)) {\n            value.forEach(v => params.append(key, v.toString()));\n          } else {\n            params.append(key, value.toString());\n          }\n        }\n      });\n    }\n\n    return this.request<any>(`/messages/search?${params.toString()}`);\n  }\n\n  // File Upload\n  async uploadFile(request: UploadFileRequest): Promise<ChatApiResponse<UploadFileResponse>> {\n    const formData = new FormData();\n    formData.append('file', request.file);\n    formData.append('conversationId', request.conversationId);\n    if (request.description) {\n      formData.append('description', request.description);\n    }\n\n    return this.request<UploadFileResponse>('/attachments', {\n      method: 'POST',\n      body: formData,\n      headers: {\n        // Remove Content-Type to let browser set it with boundary\n        ...Object.fromEntries(\n          Object.entries(this.headers).filter(([key]) => key !== 'Content-Type')\n        )\n      }\n    });\n  }\n\n  async getAttachment(attachmentId: string): Promise<ChatApiResponse<{\n    id: string;\n    filename: string;\n    mimeType: string;\n    size: number;\n    url: string;\n    thumbnailUrl?: string;\n  }>> {\n    return this.request<any>(`/attachments/${attachmentId}`);\n  }\n\n  async deleteAttachment(attachmentId: string): Promise<ChatApiResponse<void>> {\n    return this.request<void>(`/attachments/${attachmentId}`, {\n      method: 'DELETE'\n    });\n  }\n\n  // Typing Indicators\n  async startTyping(conversationId: string): Promise<ChatApiResponse<void>> {\n    return this.request<void>(`/conversations/${conversationId}/typing`, {\n      method: 'POST'\n    });\n  }\n\n  async stopTyping(conversationId: string): Promise<ChatApiResponse<void>> {\n    return this.request<void>(`/conversations/${conversationId}/typing`, {\n      method: 'DELETE'\n    });\n  }\n\n  // Reactions\n  async addReaction(\n    messageId: string,\n    emoji: string\n  ): Promise<ChatApiResponse<void>> {\n    return this.request<void>(`/messages/${messageId}/reactions`, {\n      method: 'POST',\n      body: JSON.stringify({ emoji })\n    });\n  }\n\n  async removeReaction(\n    messageId: string,\n    emoji: string\n  ): Promise<ChatApiResponse<void>> {\n    return this.request<void>(`/messages/${messageId}/reactions/${emoji}`, {\n      method: 'DELETE'\n    });\n  }\n\n  // Read Status\n  async markAsRead(messageId: string): Promise<ChatApiResponse<void>> {\n    return this.request<void>(`/messages/${messageId}/read`, {\n      method: 'POST'\n    });\n  }\n\n  async markConversationAsRead(conversationId: string): Promise<ChatApiResponse<void>> {\n    return this.request<void>(`/conversations/${conversationId}/read`, {\n      method: 'POST'\n    });\n  }\n\n  // Channel Management\n  async getChannelStatus(): Promise<ChatApiResponse<Record<string, {\n    connected: boolean;\n    enabled: boolean;\n    lastSync?: string;\n    error?: string;\n  }>>> {\n    return this.request<any>('/channels/status');\n  }\n\n  async updateChannelConfig(\n    channelType: string,\n    config: Record<string, any>\n  ): Promise<ChatApiResponse<void>> {\n    return this.request<void>(`/channels/${channelType}/config`, {\n      method: 'PATCH',\n      body: JSON.stringify(config)\n    });\n  }\n\n  async syncChannel(channelType: string): Promise<ChatApiResponse<{\n    success: boolean;\n    messagesSynced: number;\n    errors: string[];\n    lastSyncAt: string;\n  }>> {\n    return this.request<any>(`/channels/${channelType}/sync`, {\n      method: 'POST'\n    });\n  }\n\n  // Webhooks\n  async handleWebhook(request: WebhookRequest): Promise<ChatApiResponse<WebhookResponse>> {\n    return this.request<WebhookResponse>('/webhooks', {\n      method: 'POST',\n      body: JSON.stringify(request)\n    });\n  }\n\n  async getWebhookConfig(channelType: string): Promise<ChatApiResponse<{\n    url: string;\n    secret: string;\n    enabled: boolean;\n  }>> {\n    return this.request<any>(`/webhooks/${channelType}`);\n  }\n\n  async updateWebhookConfig(\n    channelType: string,\n    config: { url?: string; secret?: string; enabled?: boolean }\n  ): Promise<ChatApiResponse<void>> {\n    return this.request<void>(`/webhooks/${channelType}`, {\n      method: 'PATCH',\n      body: JSON.stringify(config)\n    });\n  }\n\n  // Analytics\n  async getAnalytics(request: AnalyticsRequest): Promise<ChatApiResponse<ChatAnalytics>> {\n    const params = new URLSearchParams({\n      startDate: request.startDate,\n      endDate: request.endDate\n    });\n\n    if (request.granularity) params.append('granularity', request.granularity);\n    if (request.channels) {\n      request.channels.forEach(channel => params.append('channels', channel));\n    }\n    if (request.includeDetails) params.append('includeDetails', 'true');\n\n    return this.request<ChatAnalytics>(`/analytics?${params.toString()}`);\n  }\n\n  async getConversationMetrics(conversationId: string): Promise<ChatApiResponse<{\n    messageCount: number;\n    participantCount: number;\n    averageResponseTime: number;\n    firstResponseTime?: number;\n    resolutionTime?: number;\n    satisfactionRating?: number;\n  }>> {\n    return this.request<any>(`/conversations/${conversationId}/metrics`);\n  }\n\n  // Health Check\n  async healthCheck(): Promise<ChatApiResponse<{\n    status: 'healthy' | 'degraded' | 'unhealthy';\n    version: string;\n    uptime: number;\n    database: { connected: boolean; latency?: number };\n    websocket: { connected: boolean; activeConnections: number };\n    channels: Record<string, { status: string; lastSync?: string }>;\n  }>> {\n    return this.request<any>('/health');\n  }\n\n  // Batch Operations\n  async batchUpdateMessages(\n    updates: Array<{ messageId: string; updates: any }>\n  ): Promise<ChatApiResponse<{ updated: number; errors: any[] }>> {\n    return this.request<any>('/messages/batch', {\n      method: 'PATCH',\n      body: JSON.stringify({ updates })\n    });\n  }\n\n  async batchDeleteMessages(messageIds: string[]): Promise<ChatApiResponse<{ deleted: number }>> {\n    return this.request<any>('/messages/batch', {\n      method: 'DELETE',\n      body: JSON.stringify({ messageIds })\n    });\n  }\n}\n\n// API Endpoints Documentation\nexport const API_ENDPOINTS = {\n  // Conversations\n  conversations: {\n    create: 'POST /conversations',\n    list: 'GET /conversations',\n    get: 'GET /conversations/:id',\n    update: 'PATCH /conversations/:id',\n    delete: 'DELETE /conversations/:id',\n    metrics: 'GET /conversations/:id/metrics',\n    read: 'POST /conversations/:id/read',\n    typing: {\n      start: 'POST /conversations/:id/typing',\n      stop: 'DELETE /conversations/:id/typing'\n    }\n  },\n  \n  // Messages\n  messages: {\n    create: 'POST /messages',\n    list: 'GET /messages',\n    get: 'GET /messages/:id',\n    update: 'PATCH /messages/:id',\n    delete: 'DELETE /messages/:id',\n    search: 'GET /messages/search',\n    batch: {\n      update: 'PATCH /messages/batch',\n      delete: 'DELETE /messages/batch'\n    },\n    reactions: {\n      add: 'POST /messages/:id/reactions',\n      remove: 'DELETE /messages/:id/reactions/:emoji'\n    },\n    read: 'POST /messages/:id/read'\n  },\n  \n  // Attachments\n  attachments: {\n    upload: 'POST /attachments',\n    get: 'GET /attachments/:id',\n    delete: 'DELETE /attachments/:id'\n  },\n  \n  // Channels\n  channels: {\n    status: 'GET /channels/status',\n    config: 'PATCH /channels/:type/config',\n    sync: 'POST /channels/:type/sync'\n  },\n  \n  // Webhooks\n  webhooks: {\n    handle: 'POST /webhooks',\n    config: {\n      get: 'GET /webhooks/:type',\n      update: 'PATCH /webhooks/:type'\n    }\n  },\n  \n  // Analytics\n  analytics: {\n    get: 'GET /analytics'\n  },\n  \n  // System\n  health: 'GET /health'\n};\n\n// Export singleton instance\nexport const chatApi = new ChatApiService();\n\n// Error handling utilities\nexport function isApiError(response: ChatApiResponse<any>): response is ChatApiResponse<never> & { success: false } {\n  return !response.success;\n}\n\nexport function getErrorMessage(response: ChatApiResponse<any>): string {\n  if (isApiError(response)) {\n    return response.error?.message || 'Unknown error occurred';\n  }\n  return '';\n}\n\nexport function getErrorCode(response: ChatApiResponse<any>): string | undefined {\n  if (isApiError(response)) {\n    return response.error?.code;\n  }\n  return undefined;\n}\n