// Accessibility Utilities\n// Utilities for improving accessibility and WCAG compliance\n\n/**\n * Focus management utilities\n */\nexport class FocusManager {\n  private static focusableSelectors = [\n    'button:not([disabled])',\n    'input:not([disabled])',\n    'select:not([disabled])',\n    'textarea:not([disabled])',\n    'a[href]',\n    '[tabindex]:not([tabindex=\"-1\"])',\n    '[contenteditable=\"true\"]'\n  ].join(', ');\n\n  /**\n   * Get all focusable elements within a container\n   */\n  static getFocusableElements(container: HTMLElement): HTMLElement[] {\n    return Array.from(\n      container.querySelectorAll(this.focusableSelectors)\n    ) as HTMLElement[];\n  }\n\n  /**\n   * Get the first focusable element within a container\n   */\n  static getFirstFocusableElement(container: HTMLElement): HTMLElement | null {\n    const focusable = this.getFocusableElements(container);\n    return focusable[0] || null;\n  }\n\n  /**\n   * Get the last focusable element within a container\n   */\n  static getLastFocusableElement(container: HTMLElement): HTMLElement | null {\n    const focusable = this.getFocusableElements(container);\n    return focusable[focusable.length - 1] || null;\n  }\n\n  /**\n   * Trap focus within a container (useful for modals)\n   */\n  static trapFocus(container: HTMLElement): () => void {\n    const focusableElements = this.getFocusableElements(container);\n    const firstElement = focusableElements[0];\n    const lastElement = focusableElements[focusableElements.length - 1];\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key !== 'Tab') return;\n\n      if (event.shiftKey) {\n        // Shift + Tab\n        if (document.activeElement === firstElement) {\n          event.preventDefault();\n          lastElement?.focus();\n        }\n      } else {\n        // Tab\n        if (document.activeElement === lastElement) {\n          event.preventDefault();\n          firstElement?.focus();\n        }\n      }\n    };\n\n    container.addEventListener('keydown', handleKeyDown);\n    \n    // Focus the first element\n    firstElement?.focus();\n\n    // Return cleanup function\n    return () => {\n      container.removeEventListener('keydown', handleKeyDown);\n    };\n  }\n\n  /**\n   * Restore focus to a previously focused element\n   */\n  static restoreFocus(element: HTMLElement | null) {\n    if (element && typeof element.focus === 'function') {\n      element.focus();\n    }\n  }\n}\n\n/**\n * Screen reader utilities\n */\nexport class ScreenReaderUtils {\n  /**\n   * Announce a message to screen readers\n   */\n  static announce(message: string, priority: 'polite' | 'assertive' = 'polite') {\n    const announcer = document.createElement('div');\n    announcer.setAttribute('aria-live', priority);\n    announcer.setAttribute('aria-atomic', 'true');\n    announcer.setAttribute('class', 'sr-only');\n    announcer.textContent = message;\n    \n    document.body.appendChild(announcer);\n    \n    // Remove after announcement\n    setTimeout(() => {\n      document.body.removeChild(announcer);\n    }, 1000);\n  }\n\n  /**\n   * Create a visually hidden element for screen readers\n   */\n  static createScreenReaderOnly(text: string): HTMLSpanElement {\n    const element = document.createElement('span');\n    element.className = 'sr-only';\n    element.textContent = text;\n    return element;\n  }\n}\n\n/**\n * Keyboard navigation utilities\n */\nexport class KeyboardNavigation {\n  /**\n   * Handle arrow key navigation for a list of elements\n   */\n  static handleArrowNavigation(\n    event: KeyboardEvent,\n    elements: HTMLElement[],\n    currentIndex: number,\n    onNavigate: (newIndex: number) => void,\n    options: {\n      horizontal?: boolean;\n      vertical?: boolean;\n      wrap?: boolean;\n    } = {}\n  ) {\n    const { horizontal = true, vertical = true, wrap = true } = options;\n    let newIndex = currentIndex;\n\n    switch (event.key) {\n      case 'ArrowUp':\n        if (vertical) {\n          event.preventDefault();\n          newIndex = currentIndex > 0 ? currentIndex - 1 : (wrap ? elements.length - 1 : 0);\n        }\n        break;\n      case 'ArrowDown':\n        if (vertical) {\n          event.preventDefault();\n          newIndex = currentIndex < elements.length - 1 ? currentIndex + 1 : (wrap ? 0 : elements.length - 1);\n        }\n        break;\n      case 'ArrowLeft':\n        if (horizontal) {\n          event.preventDefault();\n          newIndex = currentIndex > 0 ? currentIndex - 1 : (wrap ? elements.length - 1 : 0);\n        }\n        break;\n      case 'ArrowRight':\n        if (horizontal) {\n          event.preventDefault();\n          newIndex = currentIndex < elements.length - 1 ? currentIndex + 1 : (wrap ? 0 : elements.length - 1);\n        }\n        break;\n      case 'Home':\n        event.preventDefault();\n        newIndex = 0;\n        break;\n      case 'End':\n        event.preventDefault();\n        newIndex = elements.length - 1;\n        break;\n      default:\n        return;\n    }\n\n    if (newIndex !== currentIndex) {\n      onNavigate(newIndex);\n      elements[newIndex]?.focus();\n    }\n  }\n\n  /**\n   * Handle escape key to close modals/dropdowns\n   */\n  static handleEscape(event: KeyboardEvent, onEscape: () => void) {\n    if (event.key === 'Escape') {\n      event.preventDefault();\n      onEscape();\n    }\n  }\n}\n\n/**\n * Color contrast utilities\n */\nexport class ColorContrast {\n  /**\n   * Calculate relative luminance of a color\n   */\n  private static getLuminance(r: number, g: number, b: number): number {\n    const [rs, gs, bs] = [r, g, b].map(c => {\n      c = c / 255;\n      return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);\n    });\n    return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;\n  }\n\n  /**\n   * Calculate contrast ratio between two colors\n   */\n  static getContrastRatio(\n    color1: { r: number; g: number; b: number },\n    color2: { r: number; g: number; b: number }\n  ): number {\n    const lum1 = this.getLuminance(color1.r, color1.g, color1.b);\n    const lum2 = this.getLuminance(color2.r, color2.g, color2.b);\n    const brightest = Math.max(lum1, lum2);\n    const darkest = Math.min(lum1, lum2);\n    return (brightest + 0.05) / (darkest + 0.05);\n  }\n\n  /**\n   * Check if contrast ratio meets WCAG standards\n   */\n  static meetsWCAG(\n    color1: { r: number; g: number; b: number },\n    color2: { r: number; g: number; b: number },\n    level: 'AA' | 'AAA' = 'AA',\n    size: 'normal' | 'large' = 'normal'\n  ): boolean {\n    const ratio = this.getContrastRatio(color1, color2);\n    \n    if (level === 'AAA') {\n      return size === 'large' ? ratio >= 4.5 : ratio >= 7;\n    } else {\n      return size === 'large' ? ratio >= 3 : ratio >= 4.5;\n    }\n  }\n}\n\n/**\n * Motion and animation utilities for accessibility\n */\nexport class MotionUtils {\n  /**\n   * Check if user prefers reduced motion\n   */\n  static prefersReducedMotion(): boolean {\n    return window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n  }\n\n  /**\n   * Get appropriate animation duration based on user preference\n   */\n  static getAnimationDuration(normalDuration: number): number {\n    return this.prefersReducedMotion() ? 0 : normalDuration;\n  }\n\n  /**\n   * Create a media query listener for reduced motion preference\n   */\n  static onReducedMotionChange(callback: (prefersReduced: boolean) => void): () => void {\n    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    \n    const handler = (e: MediaQueryListEvent) => {\n      callback(e.matches);\n    };\n    \n    mediaQuery.addEventListener('change', handler);\n    \n    // Call immediately with current value\n    callback(mediaQuery.matches);\n    \n    // Return cleanup function\n    return () => {\n      mediaQuery.removeEventListener('change', handler);\n    };\n  }\n}\n\n/**\n * ARIA utilities\n */\nexport class AriaUtils {\n  /**\n   * Generate a unique ID for ARIA relationships\n   */\n  static generateId(prefix: string = 'aria'): string {\n    return `${prefix}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Set up ARIA describedby relationship\n   */\n  static setDescribedBy(element: HTMLElement, descriptionId: string) {\n    const existing = element.getAttribute('aria-describedby');\n    const ids = existing ? existing.split(' ') : [];\n    \n    if (!ids.includes(descriptionId)) {\n      ids.push(descriptionId);\n      element.setAttribute('aria-describedby', ids.join(' '));\n    }\n  }\n\n  /**\n   * Remove ARIA describedby relationship\n   */\n  static removeDescribedBy(element: HTMLElement, descriptionId: string) {\n    const existing = element.getAttribute('aria-describedby');\n    if (!existing) return;\n    \n    const ids = existing.split(' ').filter(id => id !== descriptionId);\n    \n    if (ids.length > 0) {\n      element.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      element.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Set up ARIA labelledby relationship\n   */\n  static setLabelledBy(element: HTMLElement, labelId: string) {\n    element.setAttribute('aria-labelledby', labelId);\n  }\n\n  /**\n   * Update ARIA live region\n   */\n  static updateLiveRegion(regionId: string, message: string, priority: 'polite' | 'assertive' = 'polite') {\n    let region = document.getElementById(regionId);\n    \n    if (!region) {\n      region = document.createElement('div');\n      region.id = regionId;\n      region.setAttribute('aria-live', priority);\n      region.setAttribute('aria-atomic', 'true');\n      region.className = 'sr-only';\n      document.body.appendChild(region);\n    }\n    \n    region.textContent = message;\n  }\n}\n\n/**\n * Touch and gesture utilities for mobile accessibility\n */\nexport class TouchUtils {\n  /**\n   * Check if touch target meets minimum size requirements (44x44px)\n   */\n  static meetsTouchTargetSize(element: HTMLElement): boolean {\n    const rect = element.getBoundingClientRect();\n    return rect.width >= 44 && rect.height >= 44;\n  }\n\n  /**\n   * Add touch-friendly spacing around interactive elements\n   */\n  static ensureTouchSpacing(element: HTMLElement, minSpacing: number = 8) {\n    const style = window.getComputedStyle(element);\n    const currentMargin = parseInt(style.margin) || 0;\n    \n    if (currentMargin < minSpacing) {\n      element.style.margin = `${minSpacing}px`;\n    }\n  }\n}\n\n// Export all utilities\nexport {\n  FocusManager,\n  ScreenReaderUtils,\n  KeyboardNavigation,\n  ColorContrast,\n  MotionUtils,\n  AriaUtils,\n  TouchUtils\n};\n