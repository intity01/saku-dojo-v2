// Data Transformers\n// Transform extracted data into standardized QuestionItem format\n\nimport type { \n  QuestionItem, \n  VocabularyItem, \n  GrammarItem, \n  ReadingItem,\n  Source,\n  LevelClassification,\n  DifficultyMetrics\n} from '../types/questionBank';\nimport type { DataSourceConfig, ETLPipelineConfig } from './config';\nimport { calculateDifficulty } from '../types/questionBank';\n\nexport interface TransformationResult {\n  items: QuestionItem[];\n  skipped: number;\n  errors: string[];\n  warnings: string[];\n}\n\nexport class DataTransformer {\n  private config: ETLPipelineConfig;\n\n  constructor(config: ETLPipelineConfig) {\n    this.config = config;\n  }\n\n  // Main transformation method\n  async transform(\n    sourceName: string, \n    rawData: any, \n    sourceConfig: DataSourceConfig\n  ): Promise<QuestionItem[]> {\n    console.log(`[Transformer] Transforming data from ${sourceName}...`);\n\n    try {\n      let items: QuestionItem[] = [];\n\n      switch (sourceName) {\n        case 'ngsl':\n          items = await this.transformNGSL(rawData, sourceConfig);\n          break;\n        case 'nawl':\n          items = await this.transformNAWL(rawData, sourceConfig);\n          break;\n        case 'jmdict':\n          items = await this.transformJMdict(rawData, sourceConfig);\n          break;\n        case 'kanjidic2':\n          items = await this.transformKanjidic2(rawData, sourceConfig);\n          break;\n        case 'tatoeba':\n          items = await this.transformTatoeba(rawData, sourceConfig);\n          break;\n        case 'wordFreqEn':\n        case 'wordFreqJa':\n          items = await this.transformWordFrequency(rawData, sourceConfig, sourceName);\n          break;\n        default:\n          throw new Error(`No transformer available for source: ${sourceName}`);\n      }\n\n      console.log(`[Transformer] Transformed ${items.length} items from ${sourceName}`);\n      return items;\n\n    } catch (error) {\n      console.error(`[Transformer] Failed to transform ${sourceName}:`, error);\n      throw error;\n    }\n  }\n\n  // NGSL transformer\n  private async transformNGSL(data: any[], sourceConfig: DataSourceConfig): Promise<VocabularyItem[]> {\n    const source: Source = {\n      name: sourceConfig.name,\n      url: sourceConfig.url,\n      license: sourceConfig.license as any,\n      attribution: sourceConfig.attribution,\n      version: sourceConfig.version\n    };\n\n    const items: VocabularyItem[] = [];\n\n    for (const row of data) {\n      try {\n        const word = row.word?.toString().trim();\n        const rank = parseInt(row.rank) || 0;\n        const frequency = parseInt(row.frequency) || 0;\n        const partOfSpeech = row.part_of_speech?.toString().trim();\n\n        if (!word || word.length < 2) continue;\n\n        // Generate vocabulary question\n        const item: VocabularyItem = {\n          id: `ngsl_${rank}_${word.replace(/[^a-zA-Z0-9]/g, '_')}`,\n          language: 'EN',\n          type: 'vocab',\n          level: this.determineEnglishLevel(rank),\n          \n          prompt: `What does \"${word}\" mean?`,\n          choices: await this.generateVocabChoices(word, partOfSpeech),\n          answer: 0, // First choice is correct\n          explanation: `\"${word}\" is a ${partOfSpeech || 'word'} commonly used in English.`,\n          \n          // Vocabulary-specific fields\n          word,\n          partOfSpeech,\n          frequency: rank,\n          \n          tags: ['vocabulary', 'ngsl', partOfSpeech || 'general'].filter(Boolean),\n          difficulty: {\n            wordFrequency: rank,\n            vocabularyLevel: this.getVocabularyLevel(rank),\n            overallDifficulty: calculateDifficulty({ wordFrequency: rank, vocabularyLevel: this.getVocabularyLevel(rank) })\n          },\n          source,\n          created: new Date().toISOString(),\n          reviewStatus: 'pending'\n        };\n\n        items.push(item);\n      } catch (error) {\n        console.warn(`[Transformer] Skipped NGSL row:`, error);\n      }\n    }\n\n    return items;\n  }\n\n  // NAWL transformer\n  private async transformNAWL(data: any[], sourceConfig: DataSourceConfig): Promise<VocabularyItem[]> {\n    const source: Source = {\n      name: sourceConfig.name,\n      url: sourceConfig.url,\n      license: sourceConfig.license as any,\n      attribution: sourceConfig.attribution,\n      version: sourceConfig.version\n    };\n\n    const items: VocabularyItem[] = [];\n\n    for (const row of data) {\n      try {\n        const word = row.word?.toString().trim();\n        const rank = parseInt(row.rank) || 0;\n        const partOfSpeech = row.part_of_speech?.toString().trim();\n        const academicField = row.academic_field?.toString().trim();\n\n        if (!word || word.length < 2) continue;\n\n        const item: VocabularyItem = {\n          id: `nawl_${rank}_${word.replace(/[^a-zA-Z0-9]/g, '_')}`,\n          language: 'EN',\n          type: 'vocab',\n          level: this.determineAcademicLevel(rank),\n          \n          prompt: `In academic context, what does \"${word}\" mean?`,\n          choices: await this.generateAcademicVocabChoices(word, partOfSpeech, academicField),\n          answer: 0,\n          explanation: `\"${word}\" is an academic term${academicField ? ` commonly used in ${academicField}` : ''}.`,\n          \n          word,\n          partOfSpeech,\n          frequency: rank + 3000, // NAWL starts after NGSL\n          \n          tags: ['vocabulary', 'nawl', 'academic', partOfSpeech, academicField].filter(Boolean),\n          difficulty: {\n            wordFrequency: rank + 3000,\n            vocabularyLevel: this.getAcademicVocabularyLevel(rank),\n            overallDifficulty: calculateDifficulty({ \n              wordFrequency: rank + 3000, \n              vocabularyLevel: this.getAcademicVocabularyLevel(rank) \n            })\n          },\n          source,\n          created: new Date().toISOString(),\n          reviewStatus: 'pending'\n        };\n\n        items.push(item);\n      } catch (error) {\n        console.warn(`[Transformer] Skipped NAWL row:`, error);\n      }\n    }\n\n    return items;\n  }\n\n  // JMdict transformer\n  private async transformJMdict(data: any[], sourceConfig: DataSourceConfig): Promise<VocabularyItem[]> {\n    const source: Source = {\n      name: sourceConfig.name,\n      url: sourceConfig.url,\n      license: sourceConfig.license as any,\n      attribution: sourceConfig.attribution,\n      version: sourceConfig.version\n    };\n\n    const items: VocabularyItem[] = [];\n\n    for (const entry of data) {\n      try {\n        const kanji = entry.kanji?.toString().trim();\n        const reading = entry.reading?.toString().trim();\n        const meaning = entry.meaning?.toString().trim();\n\n        if (!reading && !kanji) continue;\n        if (!meaning) continue;\n\n        const word = kanji || reading;\n        const kanjiCount = kanji ? kanji.length : 0;\n\n        const item: VocabularyItem = {\n          id: `jmdict_${word.replace(/[^\\u3040-\\u309F\\u30A0-\\u30FF\\u4E00-\\u9FAF\\w]/g, '_')}`,\n          language: 'JP',\n          type: 'vocab',\n          level: this.determineJapaneseLevel(kanjiCount, reading),\n          \n          prompt: `What does \"${word}\" mean?`,\n          choices: await this.generateJapaneseVocabChoices(meaning),\n          answer: 0,\n          explanation: `\"${word}\"${reading && kanji ? ` (${reading})` : ''} means \"${meaning}\".`,\n          \n          word,\n          pronunciation: reading !== kanji ? reading : undefined,\n          \n          tags: ['vocabulary', 'jmdict', 'japanese'],\n          difficulty: {\n            kanjiCount,\n            vocabularyLevel: this.getJapaneseVocabularyLevel(kanjiCount),\n            overallDifficulty: calculateDifficulty({ \n              kanjiCount, \n              vocabularyLevel: this.getJapaneseVocabularyLevel(kanjiCount) \n            })\n          },\n          source,\n          created: new Date().toISOString(),\n          reviewStatus: 'pending'\n        };\n\n        items.push(item);\n      } catch (error) {\n        console.warn(`[Transformer] Skipped JMdict entry:`, error);\n      }\n    }\n\n    return items;\n  }\n\n  // Kanjidic2 transformer\n  private async transformKanjidic2(data: any[], sourceConfig: DataSourceConfig): Promise<VocabularyItem[]> {\n    const source: Source = {\n      name: sourceConfig.name,\n      url: sourceConfig.url,\n      license: sourceConfig.license as any,\n      attribution: sourceConfig.attribution,\n      version: sourceConfig.version\n    };\n\n    const items: VocabularyItem[] = [];\n\n    for (const char of data) {\n      try {\n        const character = char.character?.toString().trim();\n        const grade = parseInt(char.grade) || 0;\n        const meaning = char.meaning?.toString().trim();\n\n        if (!character || !meaning) continue;\n\n        const item: VocabularyItem = {\n          id: `kanjidic2_${character}`,\n          language: 'JP',\n          type: 'vocab',\n          level: this.determineKanjiLevel(grade),\n          \n          prompt: `What does the kanji \"${character}\" mean?`,\n          choices: await this.generateKanjiChoices(meaning),\n          answer: 0,\n          explanation: `The kanji \"${character}\" means \"${meaning}\"${grade ? ` and is taught in grade ${grade}` : ''}.`,\n          \n          word: character,\n          \n          tags: ['kanji', 'kanjidic2', 'japanese', grade ? `grade${grade}` : 'advanced'].filter(Boolean),\n          difficulty: {\n            kanjiCount: 1,\n            vocabularyLevel: grade ? Math.min(10, grade + 2) : 8,\n            overallDifficulty: calculateDifficulty({ \n              kanjiCount: 1, \n              vocabularyLevel: grade ? Math.min(10, grade + 2) : 8 \n            })\n          },\n          source,\n          created: new Date().toISOString(),\n          reviewStatus: 'pending'\n        };\n\n        items.push(item);\n      } catch (error) {\n        console.warn(`[Transformer] Skipped Kanjidic2 entry:`, error);\n      }\n    }\n\n    return items;\n  }\n\n  // Tatoeba transformer\n  private async transformTatoeba(data: any[], sourceConfig: DataSourceConfig): Promise<ReadingItem[]> {\n    const source: Source = {\n      name: sourceConfig.name,\n      url: sourceConfig.url,\n      license: sourceConfig.license as any,\n      attribution: sourceConfig.attribution,\n      version: sourceConfig.version\n    };\n\n    const items: ReadingItem[] = [];\n    const processedSentences = new Set<string>();\n\n    for (const row of data.slice(0, 1000)) { // Limit for demo\n      try {\n        const id = row.id?.toString();\n        const language = row.language?.toString().toLowerCase();\n        const text = row.text?.toString().trim();\n\n        if (!text || !language) continue;\n        if (!['en', 'ja'].includes(language)) continue;\n        if (processedSentences.has(text)) continue;\n        if (text.length < 10 || text.length > 200) continue;\n\n        processedSentences.add(text);\n\n        const wordCount = text.split(/\\s+/).length;\n        const lang = language === 'en' ? 'EN' : 'JP';\n\n        const item: ReadingItem = {\n          id: `tatoeba_${id}_${lang}`,\n          language: lang as 'EN' | 'JP',\n          type: 'reading',\n          level: this.determineSentenceLevel(text, lang),\n          \n          prompt: `What is the main idea of this sentence?`,\n          passage: text,\n          choices: await this.generateReadingChoices(text, lang),\n          answer: 0,\n          explanation: `This sentence demonstrates common usage patterns in ${lang === 'EN' ? 'English' : 'Japanese'}.`,\n          \n          wordCount,\n          readingTime: Math.ceil(wordCount / 200), // Rough estimate\n          genre: 'general',\n          \n          tags: ['reading', 'tatoeba', language, 'sentence'],\n          difficulty: {\n            sentenceLength: text.length,\n            vocabularyLevel: this.getSentenceVocabularyLevel(text, lang),\n            overallDifficulty: calculateDifficulty({ \n              sentenceLength: text.length, \n              vocabularyLevel: this.getSentenceVocabularyLevel(text, lang) \n            })\n          },\n          source,\n          created: new Date().toISOString(),\n          reviewStatus: 'pending'\n        };\n\n        items.push(item);\n      } catch (error) {\n        console.warn(`[Transformer] Skipped Tatoeba sentence:`, error);\n      }\n    }\n\n    return items;\n  }\n\n  // Word frequency transformer\n  private async transformWordFrequency(\n    data: any[], \n    sourceConfig: DataSourceConfig, \n    sourceName: string\n  ): Promise<VocabularyItem[]> {\n    const source: Source = {\n      name: sourceConfig.name,\n      url: sourceConfig.url,\n      license: sourceConfig.license as any,\n      attribution: sourceConfig.attribution,\n      version: sourceConfig.version\n    };\n\n    const items: VocabularyItem[] = [];\n    const language = sourceName.includes('En') ? 'EN' : 'JP';\n\n    for (let i = 0; i < Math.min(1000, data.length); i++) {\n      const row = data[i];\n      \n      try {\n        const word = row.word?.toString().trim();\n        const frequency = parseInt(row.frequency) || (i + 1);\n\n        if (!word || word.length < 2) continue;\n\n        const item: VocabularyItem = {\n          id: `${sourceName}_${i + 1}_${word.replace(/[^\\w]/g, '_')}`,\n          language,\n          type: 'vocab',\n          level: language === 'EN' \n            ? this.determineEnglishLevel(frequency)\n            : this.determineJapaneseLevel(0, word),\n          \n          prompt: `How common is the word \"${word}\"?`,\n          choices: [\n            'Very common (top 1000)',\n            'Common (top 5000)',\n            'Uncommon (top 10000)',\n            'Rare (beyond top 10000)'\n          ],\n          answer: this.getFrequencyChoice(frequency),\n          explanation: `\"${word}\" ranks #${frequency} in frequency, making it ${this.getFrequencyDescription(frequency)}.`,\n          \n          word,\n          frequency,\n          \n          tags: ['vocabulary', 'frequency', sourceName.toLowerCase(), language.toLowerCase()],\n          difficulty: {\n            wordFrequency: frequency,\n            vocabularyLevel: this.getVocabularyLevelFromFrequency(frequency),\n            overallDifficulty: calculateDifficulty({ \n              wordFrequency: frequency, \n              vocabularyLevel: this.getVocabularyLevelFromFrequency(frequency) \n            })\n          },\n          source,\n          created: new Date().toISOString(),\n          reviewStatus: 'pending'\n        };\n\n        items.push(item);\n      } catch (error) {\n        console.warn(`[Transformer] Skipped frequency word:`, error);\n      }\n    }\n\n    return items;\n  }\n\n  // Level determination helpers\n  private determineEnglishLevel(rank: number): LevelClassification {\n    if (rank <= 1000) return { system: 'CEFR', level: 'A1' };\n    if (rank <= 2000) return { system: 'CEFR', level: 'A2' };\n    if (rank <= 3000) return { system: 'CEFR', level: 'B1' };\n    if (rank <= 4000) return { system: 'CEFR', level: 'B2' };\n    if (rank <= 5000) return { system: 'CEFR', level: 'C1' };\n    return { system: 'CEFR', level: 'C2' };\n  }\n\n  private determineAcademicLevel(rank: number): LevelClassification {\n    if (rank <= 200) return { system: 'CEFR', level: 'B2' };\n    if (rank <= 400) return { system: 'CEFR', level: 'C1' };\n    return { system: 'CEFR', level: 'C2' };\n  }\n\n  private determineJapaneseLevel(kanjiCount: number, reading: string): LevelClassification {\n    if (kanjiCount === 0) return { system: 'JLPT', level: 'N5' };\n    if (kanjiCount <= 2) return { system: 'JLPT', level: 'N4' };\n    if (kanjiCount <= 4) return { system: 'JLPT', level: 'N3' };\n    if (kanjiCount <= 6) return { system: 'JLPT', level: 'N2' };\n    return { system: 'JLPT', level: 'N1' };\n  }\n\n  private determineKanjiLevel(grade: number): LevelClassification {\n    if (grade >= 1 && grade <= 2) return { system: 'JLPT', level: 'N5' };\n    if (grade >= 3 && grade <= 4) return { system: 'JLPT', level: 'N4' };\n    if (grade >= 5 && grade <= 6) return { system: 'JLPT', level: 'N3' };\n    if (grade >= 7 && grade <= 9) return { system: 'JLPT', level: 'N2' };\n    return { system: 'JLPT', level: 'N1' };\n  }\n\n  private determineSentenceLevel(text: string, language: string): LevelClassification {\n    const length = text.length;\n    \n    if (language === 'EN') {\n      if (length <= 50) return { system: 'CEFR', level: 'A1' };\n      if (length <= 80) return { system: 'CEFR', level: 'A2' };\n      if (length <= 120) return { system: 'CEFR', level: 'B1' };\n      if (length <= 160) return { system: 'CEFR', level: 'B2' };\n      return { system: 'CEFR', level: 'C1' };\n    } else {\n      if (length <= 30) return { system: 'JLPT', level: 'N5' };\n      if (length <= 50) return { system: 'JLPT', level: 'N4' };\n      if (length <= 80) return { system: 'JLPT', level: 'N3' };\n      if (length <= 120) return { system: 'JLPT', level: 'N2' };\n      return { system: 'JLPT', level: 'N1' };\n    }\n  }\n\n  // Choice generation helpers\n  private async generateVocabChoices(word: string, partOfSpeech?: string): Promise<string[]> {\n    // Mock choice generation - in reality would use semantic similarity\n    const mockChoices = [\n      `A ${partOfSpeech || 'word'} meaning...`,\n      'An unrelated concept',\n      'Another unrelated concept',\n      'A third unrelated concept'\n    ];\n    return mockChoices;\n  }\n\n  private async generateAcademicVocabChoices(word: string, partOfSpeech?: string, field?: string): Promise<string[]> {\n    return [\n      `An academic term in ${field || 'general studies'}`,\n      'A common everyday word',\n      'A technical term from another field',\n      'A colloquial expression'\n    ];\n  }\n\n  private async generateJapaneseVocabChoices(meaning: string): Promise<string[]> {\n    return [\n      meaning,\n      'A different meaning',\n      'Another different meaning',\n      'A third different meaning'\n    ];\n  }\n\n  private async generateKanjiChoices(meaning: string): Promise<string[]> {\n    return [\n      meaning,\n      'A different kanji meaning',\n      'Another kanji meaning',\n      'A third kanji meaning'\n    ];\n  }\n\n  private async generateReadingChoices(text: string, language: string): Promise<string[]> {\n    return [\n      'The main concept from the sentence',\n      'An unrelated concept',\n      'Another unrelated concept',\n      'A third unrelated concept'\n    ];\n  }\n\n  // Difficulty calculation helpers\n  private getVocabularyLevel(rank: number): number {\n    if (rank <= 500) return 2;\n    if (rank <= 1000) return 3;\n    if (rank <= 2000) return 4;\n    if (rank <= 3000) return 5;\n    if (rank <= 4000) return 6;\n    if (rank <= 5000) return 7;\n    return 8;\n  }\n\n  private getAcademicVocabularyLevel(rank: number): number {\n    return Math.min(10, 6 + Math.floor(rank / 200));\n  }\n\n  private getJapaneseVocabularyLevel(kanjiCount: number): number {\n    return Math.min(10, 3 + kanjiCount);\n  }\n\n  private getSentenceVocabularyLevel(text: string, language: string): number {\n    const length = text.length;\n    if (language === 'EN') {\n      return Math.min(10, Math.floor(length / 20) + 2);\n    } else {\n      return Math.min(10, Math.floor(length / 15) + 3);\n    }\n  }\n\n  private getVocabularyLevelFromFrequency(frequency: number): number {\n    if (frequency <= 100) return 2;\n    if (frequency <= 500) return 3;\n    if (frequency <= 1000) return 4;\n    if (frequency <= 2000) return 5;\n    if (frequency <= 5000) return 6;\n    if (frequency <= 10000) return 7;\n    return 8;\n  }\n\n  private getFrequencyChoice(frequency: number): number {\n    if (frequency <= 1000) return 0;\n    if (frequency <= 5000) return 1;\n    if (frequency <= 10000) return 2;\n    return 3;\n  }\n\n  private getFrequencyDescription(frequency: number): string {\n    if (frequency <= 1000) return 'very common';\n    if (frequency <= 5000) return 'common';\n    if (frequency <= 10000) return 'uncommon';\n    return 'rare';\n  }\n}\n