// Data Loaders\n// Load transformed data into final question bank format\n\nimport type { \n  QuestionItem, \n  QuestionCollection, \n  Source \n} from '../types/questionBank';\nimport type { DataSourceConfig, ETLPipelineConfig } from './config';\nimport { OUTPUT_PATHS } from './config';\n\nexport interface LoadResult {\n  success: boolean;\n  collections: QuestionCollection[];\n  itemCount: number;\n  outputPath: string;\n  error?: string;\n}\n\nexport class DataLoader {\n  private config: ETLPipelineConfig;\n\n  constructor(config: ETLPipelineConfig) {\n    this.config = config;\n  }\n\n  // Main loading method\n  async load(\n    sourceName: string,\n    items: QuestionItem[],\n    sourceConfig: DataSourceConfig\n  ): Promise<QuestionCollection[]> {\n    console.log(`[Loader] Loading ${items.length} items from ${sourceName}...`);\n\n    try {\n      // Group items by type and level for collections\n      const collections = this.groupItemsIntoCollections(sourceName, items, sourceConfig);\n      \n      // Save collections to files\n      for (const collection of collections) {\n        await this.saveCollection(collection);\n      }\n\n      console.log(`[Loader] Successfully loaded ${collections.length} collections from ${sourceName}`);\n      return collections;\n\n    } catch (error) {\n      console.error(`[Loader] Failed to load ${sourceName}:`, error);\n      throw error;\n    }\n  }\n\n  // Group items into logical collections\n  private groupItemsIntoCollections(\n    sourceName: string,\n    items: QuestionItem[],\n    sourceConfig: DataSourceConfig\n  ): QuestionCollection[] {\n    const collections: QuestionCollection[] = [];\n    \n    // Group by type and level\n    const groups = new Map<string, QuestionItem[]>();\n    \n    for (const item of items) {\n      const key = `${item.type}_${item.level.system}_${item.level.level}`;\n      if (!groups.has(key)) {\n        groups.set(key, []);\n      }\n      groups.get(key)!.push(item);\n    }\n\n    // Create collections from groups\n    for (const [key, groupItems] of groups) {\n      const [type, levelSystem, levelValue] = key.split('_');\n      const firstItem = groupItems[0];\n      \n      const collection: QuestionCollection = {\n        id: `${sourceName}_${key}`,\n        title: this.generateCollectionTitle(sourceName, type, levelSystem, levelValue),\n        description: this.generateCollectionDescription(sourceName, type, levelSystem, levelValue, groupItems.length),\n        language: firstItem.language,\n        level: firstItem.level,\n        type: firstItem.type,\n        \n        items: groupItems,\n        totalItems: groupItems.length,\n        \n        tags: this.generateCollectionTags(sourceName, type, levelSystem, levelValue),\n        difficulty: this.determineDifficulty(groupItems),\n        estimatedTime: this.estimateTime(groupItems),\n        \n        sources: [{\n          name: sourceConfig.name,\n          url: sourceConfig.url,\n          license: sourceConfig.license as any,\n          attribution: sourceConfig.attribution,\n          version: sourceConfig.version\n        }],\n        license: sourceConfig.license as any,\n        attribution: sourceConfig.attribution,\n        \n        reviewStatus: 'draft',\n        version: '1.0.0',\n        \n        created: new Date().toISOString(),\n        modified: new Date().toISOString()\n      };\n\n      collections.push(collection);\n    }\n\n    return collections;\n  }\n\n  // Save collection to file\n  private async saveCollection(collection: QuestionCollection): Promise<void> {\n    const filename = `${collection.id}.json`;\n    const filepath = `${OUTPUT_PATHS.final}/${filename}`;\n    \n    try {\n      // In a real implementation, you would write to the file system\n      // For now, we'll simulate the save operation\n      console.log(`[Loader] Saving collection to ${filepath}`);\n      \n      const data = {\n        ...collection,\n        metadata: {\n          generated: new Date().toISOString(),\n          generator: 'Saku Dojo ETL Pipeline v1.0',\n          format: 'question-bank-v1',\n          compression: this.config.output.compression,\n          validation: this.config.output.validation\n        }\n      };\n\n      // Simulate file write\n      const jsonData = JSON.stringify(data, null, 2);\n      console.log(`[Loader] Collection ${collection.id} saved (${jsonData.length} bytes)`);\n      \n      // In real implementation:\n      // await fs.writeFile(filepath, jsonData, 'utf-8');\n      \n    } catch (error) {\n      console.error(`[Loader] Failed to save collection ${collection.id}:`, error);\n      throw error;\n    }\n  }\n\n  // Collection metadata generation\n  private generateCollectionTitle(\n    sourceName: string, \n    type: string, \n    levelSystem: string, \n    levelValue: string\n  ): string {\n    const sourceNames: Record<string, string> = {\n      ngsl: 'NGSL',\n      nawl: 'NAWL', \n      jmdict: 'JMdict',\n      kanjidic2: 'KANJIDIC2',\n      tatoeba: 'Tatoeba',\n      wordFreqEn: 'English Frequency',\n      wordFreqJa: 'Japanese Frequency'\n    };\n\n    const typeNames: Record<string, string> = {\n      vocab: 'Vocabulary',\n      grammar: 'Grammar',\n      reading: 'Reading',\n      listening: 'Listening',\n      pronunciation: 'Pronunciation',\n      conversation: 'Conversation'\n    };\n\n    const sourceName_ = sourceNames[sourceName] || sourceName.toUpperCase();\n    const typeName = typeNames[type] || type.charAt(0).toUpperCase() + type.slice(1);\n    \n    return `${sourceName_} ${typeName} ${levelSystem} ${levelValue}`;\n  }\n\n  private generateCollectionDescription(\n    sourceName: string,\n    type: string,\n    levelSystem: string,\n    levelValue: string,\n    itemCount: number\n  ): string {\n    const descriptions: Record<string, string> = {\n      ngsl: 'High-frequency English vocabulary from the New General Service List',\n      nawl: 'Academic English vocabulary from the New Academic Word List',\n      jmdict: 'Japanese vocabulary from the JMdict dictionary project',\n      kanjidic2: 'Japanese kanji characters from the KANJIDIC2 database',\n      tatoeba: 'Real-world sentences from the Tatoeba project',\n      wordFreqEn: 'English words ranked by frequency of use',\n      wordFreqJa: 'Japanese words ranked by frequency of use'\n    };\n\n    const baseDescription = descriptions[sourceName] || `${sourceName} language learning content`;\n    return `${baseDescription}. This collection contains ${itemCount} ${type} questions at ${levelSystem} ${levelValue} level.`;\n  }\n\n  private generateCollectionTags(\n    sourceName: string,\n    type: string,\n    levelSystem: string,\n    levelValue: string\n  ): string[] {\n    const tags = [sourceName, type, levelSystem.toLowerCase(), levelValue.toLowerCase()];\n    \n    // Add language-specific tags\n    if (['ngsl', 'nawl', 'wordFreqEn'].includes(sourceName)) {\n      tags.push('english');\n    } else if (['jmdict', 'kanjidic2', 'wordFreqJa'].includes(sourceName)) {\n      tags.push('japanese');\n    }\n    \n    // Add type-specific tags\n    if (type === 'vocab') {\n      tags.push('vocabulary', 'words');\n    } else if (type === 'reading') {\n      tags.push('comprehension', 'sentences');\n    }\n    \n    // Add level-specific tags\n    if (levelSystem === 'CEFR') {\n      if (['A1', 'A2'].includes(levelValue)) tags.push('beginner');\n      else if (['B1', 'B2'].includes(levelValue)) tags.push('intermediate');\n      else tags.push('advanced');\n    } else if (levelSystem === 'JLPT') {\n      if (['N5', 'N4'].includes(levelValue)) tags.push('beginner');\n      else if (levelValue === 'N3') tags.push('intermediate');\n      else tags.push('advanced');\n    }\n    \n    return [...new Set(tags)]; // Remove duplicates\n  }\n\n  private determineDifficulty(items: QuestionItem[]): 'Easy' | 'Medium' | 'Hard' {\n    if (items.length === 0) return 'Medium';\n    \n    const avgDifficulty = items.reduce((sum, item) => {\n      return sum + (item.difficulty.overallDifficulty || 5);\n    }, 0) / items.length;\n    \n    if (avgDifficulty <= 3.5) return 'Easy';\n    if (avgDifficulty <= 6.5) return 'Medium';\n    return 'Hard';\n  }\n\n  private estimateTime(items: QuestionItem[]): number {\n    // Estimate time in minutes based on question type and count\n    const baseTimePerItem = {\n      vocab: 0.5,      // 30 seconds per vocab question\n      grammar: 1.0,    // 1 minute per grammar question\n      reading: 2.0,    // 2 minutes per reading question\n      listening: 1.5,  // 1.5 minutes per listening question\n      pronunciation: 1.0,\n      conversation: 1.5\n    };\n    \n    const totalTime = items.reduce((sum, item) => {\n      const baseTime = baseTimePerItem[item.type] || 1.0;\n      const difficultyMultiplier = (item.difficulty.overallDifficulty || 5) / 5;\n      return sum + (baseTime * difficultyMultiplier);\n    }, 0);\n    \n    return Math.ceil(totalTime);\n  }\n\n  // Batch operations\n  async loadMultipleSources(\n    sources: Array<{ sourceName: string; items: QuestionItem[]; config: DataSourceConfig }>\n  ): Promise<QuestionCollection[]> {\n    const allCollections: QuestionCollection[] = [];\n    \n    for (const { sourceName, items, config } of sources) {\n      try {\n        const collections = await this.load(sourceName, items, config);\n        allCollections.push(...collections);\n      } catch (error) {\n        console.error(`[Loader] Failed to load ${sourceName}:`, error);\n        // Continue with other sources\n      }\n    }\n    \n    return allCollections;\n  }\n\n  // Export operations\n  async exportCollection(\n    collection: QuestionCollection,\n    format: 'json' | 'csv' | 'anki' | 'quizlet'\n  ): Promise<string> {\n    console.log(`[Loader] Exporting collection ${collection.id} as ${format}...`);\n    \n    switch (format) {\n      case 'json':\n        return this.exportAsJSON(collection);\n      case 'csv':\n        return this.exportAsCSV(collection);\n      case 'anki':\n        return this.exportAsAnki(collection);\n      case 'quizlet':\n        return this.exportAsQuizlet(collection);\n      default:\n        throw new Error(`Unsupported export format: ${format}`);\n    }\n  }\n\n  private exportAsJSON(collection: QuestionCollection): string {\n    return JSON.stringify(collection, null, 2);\n  }\n\n  private exportAsCSV(collection: QuestionCollection): string {\n    const headers = ['ID', 'Type', 'Language', 'Level', 'Prompt', 'Answer', 'Explanation', 'Tags'];\n    const rows = [headers.join(',')];\n    \n    for (const item of collection.items) {\n      const row = [\n        item.id,\n        item.type,\n        item.language,\n        `${item.level.system}:${item.level.level}`,\n        `\"${item.prompt.replace(/\"/g, '\"\"')}\"`,\n        `\"${item.answer}\"`,\n        `\"${item.explanation || ''}\"`,\n        `\"${item.tags.join(';')}\"`\n      ];\n      rows.push(row.join(','));\n    }\n    \n    return rows.join('\\n');\n  }\n\n  private exportAsAnki(collection: QuestionCollection): string {\n    // Anki deck format (simplified)\n    const lines: string[] = [];\n    \n    for (const item of collection.items) {\n      // Front\\tBack\\tTags format\n      const front = item.prompt;\n      const back = `${item.answer}${item.explanation ? `<br><br>${item.explanation}` : ''}`;\n      const tags = item.tags.join(' ');\n      \n      lines.push(`${front}\\t${back}\\t${tags}`);\n    }\n    \n    return lines.join('\\n');\n  }\n\n  private exportAsQuizlet(collection: QuestionCollection): string {\n    // Quizlet format (term\\tdefinition)\n    const lines: string[] = [];\n    \n    for (const item of collection.items) {\n      if (item.type === 'vocab') {\n        // For vocabulary, use word as term and explanation as definition\n        const term = item.prompt.replace(/^What does \"(.+)\" mean\\?$/, '$1');\n        const definition = item.explanation || item.answer.toString();\n        lines.push(`${term}\\t${definition}`);\n      } else {\n        // For other types, use prompt and answer\n        lines.push(`${item.prompt}\\t${item.answer}`);\n      }\n    }\n    \n    return lines.join('\\n');\n  }\n\n  // Validation and cleanup\n  async validateOutput(collections: QuestionCollection[]): Promise<{\n    valid: boolean;\n    errors: string[];\n    warnings: string[];\n  }> {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    \n    for (const collection of collections) {\n      // Validate collection structure\n      if (!collection.id) errors.push(`Collection missing ID`);\n      if (!collection.title) errors.push(`Collection ${collection.id} missing title`);\n      if (!collection.items || collection.items.length === 0) {\n        errors.push(`Collection ${collection.id} has no items`);\n      }\n      \n      // Validate items\n      for (const item of collection.items || []) {\n        if (!item.id) errors.push(`Item missing ID in collection ${collection.id}`);\n        if (!item.prompt) errors.push(`Item ${item.id} missing prompt`);\n        if (item.answer === undefined || item.answer === null) {\n          errors.push(`Item ${item.id} missing answer`);\n        }\n        \n        // Check for potential issues\n        if (item.prompt.length < 10) {\n          warnings.push(`Item ${item.id} has very short prompt`);\n        }\n        if (!item.explanation) {\n          warnings.push(`Item ${item.id} missing explanation`);\n        }\n      }\n    }\n    \n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  // Cleanup and maintenance\n  async cleanup(): Promise<void> {\n    console.log('[Loader] Performing cleanup...');\n    // In real implementation, would clean up temporary files, etc.\n  }\n\n  // Health check\n  async healthCheck(): Promise<{ status: 'healthy' | 'degraded'; details: any }> {\n    return {\n      status: 'healthy',\n      details: {\n        outputPath: OUTPUT_PATHS.final,\n        timestamp: new Date().toISOString()\n      }\n    };\n  }\n}\n